<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>连分数悖论</title>
      <link href="/2019/%E8%BF%9E%E5%88%86%E6%95%B0%E6%82%96%E8%AE%BA/"/>
      <url>/2019/%E8%BF%9E%E5%88%86%E6%95%B0%E6%82%96%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>$By\ King$</p><p>开学了，文章可能质量下降，见谅。</p><p>今天带来一个悖论。</p><a id="more"></a><p>这个悖论是我在<a href="https://space.bilibili.com/4211280" target="_blank" rel="noopener">$B$站的卖骚老姐</a>看到的，网址是<a href="https://www.bilibili.com/video/av40753636" target="_blank" rel="noopener">$av40753636$</a>。</p><p>首先，视频抛出一个悖论：</p><script type="math/tex; mode=display">1=\frac{2}{3-1}=\frac{2}{3-\frac{2}{3-1}}=\frac{2}{3-\frac{2}{3-\frac{2}{3-\dots}}}</script><script type="math/tex; mode=display">2=\frac{2}{3-2}=\frac{2}{3-\frac{2}{3-2}}=\frac{2}{3-\frac{2}{3-\frac{2}{3-\dots}}}</script><p>从而说明$1=2$。</p><p>很明显这是错误的（不然世界早就崩塌了），然而视频也没有解释，而是卖了个关子，然后在评论区里讨论。</p><p>然而很多评论里都是说类似于<code>有理数不能表示成无限连分数的形式</code>的解释，那我就忍不住想要举下面的例子：</p><script type="math/tex; mode=display">\sqrt{2}=\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\sqrt{2}}=\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\sqrt{2}}}=\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\dots}}}</script><script type="math/tex; mode=display">\sqrt{3}=\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\sqrt{3}}=\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\sqrt{3}}}=\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\frac{\sqrt{6}}{\sqrt{2}+\sqrt{3}-\dots}}}</script><p>然而他们是无理数，但这还是能得出$\sqrt{2}=\sqrt{3}$这种错误的结论。</p><p>类似的，只要$a$和$b$都是实数，那么$a=b$：</p><script type="math/tex; mode=display">a=\frac{ab}{a+b-a}=\frac{ab}{a+b-\frac{ab}{a+b-a}}=\frac{ab}{a+b-\frac{ab}{a+b-\frac{ab}{a+b-\dots}}}</script><script type="math/tex; mode=display">b=\frac{ab}{a+b-b}=\frac{ab}{a+b-\frac{ab}{a+b-b}}=\frac{ab}{a+b-\frac{ab}{a+b-\frac{ab}{a+b-\dots}}}</script><p>那么我们要怎么推翻它呢，当然是找出$\frac{ab}{a+b-\frac{ab}{a+b-\frac{ab}{a+b-\dots}}}$的解了。</p><p>考虑到式子中包含本身，那么我们用$A$来代替$\frac{ab}{a+b-\frac{ab}{a+b-\frac{ab}{a+b-\dots}}}$。然后求出$A$的值。</p><script type="math/tex; mode=display">A=\frac{ab}{a+b-A}</script><script type="math/tex; mode=display">A(a+b-A)=ab</script><script type="math/tex; mode=display">Aa+Ab-A^2=ab</script><script type="math/tex; mode=display">(-1)A^2+A(a+b)+(-ab)=0</script><script type="math/tex; mode=display">A=\frac{-(a+b)\pm\sqrt{(a+b)^2-4\times(-1)\times(-ab)}}{2\times(-1)}</script><script type="math/tex; mode=display">A=\frac{-(a+b)\pm\sqrt{(a+b)^2-4ab}}{-2}</script><script type="math/tex; mode=display">A=\frac{-(a+b)\pm(a-b)}{-2}</script><script type="math/tex; mode=display">A=\frac{-(a+b)+(a-b)}{-2}或\frac{-(a+b)-(a-b)}{-2}</script><script type="math/tex; mode=display">A=a或b</script><p>这时，真相就在眼前。</p><p>其实这就是把一个二次方程的两个解看做相等，类似于</p><blockquote><p>$\because2=\sqrt{4}$<br>$-2=\sqrt{4}$<br>$\therefore2=-2$</p></blockquote><p>这样子。（感觉水了一期）</p><script type="math/tex; mode=display">\Huge The\ End.</script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 连分数 </tag>
            
            <tag> 悖论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷知识：数字黑洞4循环</title>
      <link href="/2019/%E5%86%B7%E7%9F%A5%E8%AF%86%EF%BC%9A%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E4%E5%BE%AA%E7%8E%AF/"/>
      <url>/2019/%E5%86%B7%E7%9F%A5%E8%AF%86%EF%BC%9A%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E4%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>$By\ King$</p><p>前几天看<a href="http://www.matrix67.com/blog/archives/4520" target="_blank" rel="noopener">$M67$牛的一篇文章</a>，看到这么一个有意思的东西：</p><blockquote><p>不断取数字英文表达的字符数，最后总会得到数字$4$</p></blockquote><a id="more"></a><p>例如说$11$，他的英文表达是$eleven$。</p><p>然后$eleven$的字符数是$6$，$6$的英文表达是$six\dots$</p><script type="math/tex; mode=display">11(eleven)\to6(six)\to3(three)\to5(five)\to4(four)</script><p>你会发现，无论是什么数字，它最终都会变成$4$。</p><p>再举一个例子$114514$：</p><script type="math/tex; mode=display">114514(eleven\ thousand\ forty-five\ hundred\ and\ fourteen)\to42(forty-two)\to9(nine)\to4(four)</script><p>你会发现这仍然是会到$4$，神奇吧。</p><p>这是$1$到$100$的转换图（来源于上面的$M67$牛的文章）：</p><p><img src="http://www.matrix67.com/blogimage_2011/201108081.png" alt></p><p>而这个是$1$到$1000$的，更为壮观（仍然来源于上面的$M67$牛的文章）：</p><p><img src="http://www.matrix67.com/blogimage_2011/201108082.png" alt></p><h1 id="1-证明他！"><a href="#1-证明他！" class="headerlink" title="$1.$证明他！"></a>$1.$证明他！</h1><p>$M67$牛那篇文章也大概有说一些关于证明的。</p><p>这个证明我想了大概两天，可能还不太严谨，如果有误可以下面评论告诉我。</p><p>首先先证明英文表达的长度是以对数级增长的（就这里想了很久）。</p><p>首先我把$0$到$10^9-1$的英文表达列举了一下（其实也算不上列举，计算吧）：</p><p><img src="https://s2.ax1x.com/2019/08/29/mqQwwT.png" alt></p><p>然而似乎没有什么用（<del>除了好看一点</del>）然后去了<a href="http://oeis.org/A005589" target="_blank" rel="noopener">oeis.org</a>找了一下，也没有证明，但是我找到了<a href="http://oeis.org/A005589/b005589.txt" target="_blank" rel="noopener">数字对应的表</a>，于是我尝试着把他们描在$GeoGebra$上（只描了前$100$，太多会卡）：</p><p><img src="https://s2.ax1x.com/2019/08/29/mqQuOP.png" alt></p><p>然后我用了$\log_{1.5}n$去近似它（不会近似随便搞）：</p><p><img src="https://s2.ax1x.com/2019/08/29/mqQVWd.png" alt></p><p>但好像还是没有进展，然而那时是$12$点多了，于是赶紧去洗澡。</p><p>在洗澡的过程中，我突然想到一种证法（就像阿基米德）似乎挺简单，这里说一下：</p><p>还是这张图</p><p><img src="https://s2.ax1x.com/2019/08/29/mqQwwT.png" alt></p><p>在这张图，你可以看到，数字范围每乘$10$，英文表达的单词的长度就加一点，这就可以说明这是$log$级别增长了。</p><p>因为如果$a$每乘$10$，$b$就加$1$，那么$b$对于$a$来说是$log_{10}a$的增长的</p><p>类似的，假如每次增加$x$，那么这个长度对于$a$来说是$log_{\sqrt[x]{10}}a$的增长。</p><p>这样就可以证明得出英文表达的长度是以对数级增长的。</p><p>然后后面就简单了：</p><p>因为数字是线性增长的，英文表达的长度是以对数级增长，然而对数级增长赶不上线性增长，那么数字一定会越来越小，直到小于等于$4$。</p><p>然后又是分类讨论：</p><ul><li>当最后长度是$4$时，已经结束，不用再想了</li><li>当最后长度是$3$时，会这样变$3(three)\to5(five)\to4(four)$</li><li>当最后长度是$2$时，会这样变$2(two)\to3(three)\to5(five)\to4(four)$</li><li>当最后长度是$1$时，会这样变$1(one)\to3(three)\to5(five)\to4(four)$</li></ul><p>那么无论是什么数，最终一定会变成$4$。</p><h1 id="2-中文"><a href="#2-中文" class="headerlink" title="$2.$中文"></a>$2.$中文</h1><p>那，如果是中文去计算笔画，还会这样吗？</p><p>也是一样的，用类似的方法可以证明最后会变成$1,2,3$或跳入$4,5$循环。</p><p>其他有一些语言也是如此（见<a href="http://oeis.org/A005589" target="_blank" rel="noopener">A005589</a><code>COMMENTS</code>一段）</p><blockquote><p>Explanation of Diane Karloff’s observation above: In many languages there exists a number N, after which all numbers are written with fewer letters than the number itself. N is 4 in English, German and Bulgarian, and 11 in Russian. If in the interval [1,N] there are numbers equal to the number of their letters, then they are attractors. In English and German the only attractor is 4, in Bulgarian 3, in Russian there are two, 3 and 11. In the interval [1,N] there may also exist loops of numbers, for instance 4 and 6 in Bulgarian (6 and 4 letters respectively) or 4,5 and 6 in Russian (6,4 and 5 letters respectively). There are no loops in English, therefore the above observation is true. - Ivan N. Ianakiev, Sep 20 2014</p></blockquote><h1 id="3-其他类似的"><a href="#3-其他类似的" class="headerlink" title="$3.$其他类似的"></a>$3.$其他类似的</h1><p>其实我之前也见过许多其他类似的，例如下面两个：</p><ul><li>不断取数字每一位的和，最后总会小于$10$<br>例如$49815\to4+9+8+1+5(27)\to2+7(9)$</li><li>不断取数字每一位的乘积，最后总会小于$10$<br>例如$23333\to2\times3\times3\times3\times3(162)\to1\times6\times2(12)\to1\times2(2)$</li></ul><p>当然还要<del>水一会</del>证明。</p><p>先证明第一个，这个比较简单：</p><p>首先我们把$n$每一位拆出来，例如$49815$拆成$40000+9000+800+10+5$这样，计算一次后是$4+9+8+1+5$。</p><p>那么$n=10^ma_m+10^{m-1}a_{m-1}+\dots+10^2a_2+10a_1+a_0$这种类型（$m,m-1,\dots0\in N,0\le a_i&lt;10,10^ma_m\ne0$），每计算一次后就是$a_m+a_{m-1}+\dots+a_2+a_1+a_0$，我们把它们相减就得到：$(10^{m}-1)a_m+(10^{m-1}-1)a_{m-1}+\dots+99a_2+9a_1$，只要我们证明他是个正数即可。（是不是有点太麻烦了）</p><p>因为$m,m-1,\dots0\in N$，那么$10^{m,m-1,\dots0}\in N_+$，然后$0\le a_i&lt;10$，那么$10^{m,m-1,\dots0}a_i\in N$，把他们加起来，一定$\in N$，而且仅当$n=10^0a_0$时等于$0$，但此时$n&lt;10$，所以数字会越来越小，最后变成$10$以内的数，然后不再改变。</p><p>第二个的证法也是差不多的，我直接把我之前的证明写出来：</p><p>假设$n=10^ma_m+10^{m-1}a_{m-1}+\dots+10a_1+a_0$（$m,m-1,\dots0\in N,0\le a_i&lt;10,10^ma_m\ne0$）。</p><p>计算一次后的结果是$a_{m-1}a_{m-2}\dots a_1a_0$。</p><p>然而之前说过：$0\le a_i&lt;10$，那么$a_i$最大只可能是$9$，$a_{m-1}a_{m-2}\dots a_1a_0$最大只可能是$9^m$。</p><p>但是，他比$10^na_m$还小，因为上面说了$10^ma_m\ne0$，那么就说明了$a_m\ne0$。</p><p>而且$a_m$最小也是$1$，也就是说$10^ma_m$最小也是$10^m$，然而$9^m\le10^m$（当$m=0$时取等号），所以$a_{m-1}a_{m-2}\dots a_1a_0\le10^ma_m$</p><p>所以数字会变得越来越小，直到$m=0$时，这时候数字也只剩下了一位数。</p><hr><script type="math/tex; mode=display">\Huge The\ End.</script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冷知识 </tag>
            
            <tag> 黑洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作一个成语接龙AI</title>
      <link href="/2019/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E6%88%90%E8%AF%AD%E6%8E%A5%E9%BE%99AI/"/>
      <url>/2019/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E6%88%90%E8%AF%AD%E6%8E%A5%E9%BE%99AI/</url>
      
        <content type="html"><![CDATA[<p>$By\ King$</p><p>最近闲的蛋疼，搞了个成语接龙$AI$</p><p>没错，你没有听错，是$\Large AI$，会学习的<del>人工智能</del>菜鸡。</p><a id="more"></a><p>现在手把手教你搭建一个成语接龙$AI$。</p><p>我搞这个的目的大概是：</p><ul><li>跟$QQ$小冰玩</li><li><del>装逼</del></li><li><del>虐菜</del></li></ul><p><del>说实在的，这个AI很菜。</del></p><p><strong>注：这里的成语接龙定义：</strong></p><ul><li><strong>成语的首字要与上个成语的末字相同，并非拼音相同！例如 <code>稀奇古怪-怪声怪气</code> 就是一个合法的例子</strong></li><li><strong>当有一方接不上时，另一方胜利</strong></li><li><strong>由玩家指定开头成语</strong></li></ul><hr><h1 id="1-成语库"><a href="#1-成语库" class="headerlink" title="$1.$成语库"></a>$1.$成语库</h1><p>若要想制作一个好的$AI$，那么第一步一定是拥有一个完整的成语库。</p><h2 id="1-寻找成语库"><a href="#1-寻找成语库" class="headerlink" title="$(1)$寻找成语库"></a>$(1)$寻找成语库</h2><p>目前使用的是在$github$上的一个成语库：<a href="https://github.com/pwxcoo/chinese-xinhua/blob/master/data/idiom.json" target="_blank" rel="noopener">戳我</a></p><p>首先点击右边的<code>Download</code>，等它加载完，然后一波<code>Ctrl+A Ctrl+C</code>，复制到文本文档，起名为<code>data.txt</code>。</p><p>加载完是指浏览器标签页图标不再是加载圈圈，顺便检查一下文本文档最后面是否是<code>&quot;做张做智&quot;, &quot;abbreviation&quot;: &quot;zzzz&quot;}]</code>这几个字。如果是，恭喜你可以进入下一步了。</p><h2 id="2-筛选"><a href="#2-筛选" class="headerlink" title="$(2)$筛选"></a>$(2)$筛选</h2><p>你会发现复制过来有很多定义啊，来源啊这些。而我们只需要一样东西——成语</p><p>手筛非常麻烦（如果您很闲），肯定是让程序帮你筛啦！</p><p>仔细观察可以发现：<code>&quot;word&quot;:</code>后面都是成语。</p><p>所以利用<code>find</code>函数截取。</p><p>具体实现<code>cut.cpp</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">I</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">O</span><span class="params">(<span class="string">"data-fixed.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(getline(I,s))&#123;<span class="comment">//整行读入 </span></span><br><span class="line"><span class="keyword">if</span>(s.find(<span class="string">"\"word\": \""</span>)==<span class="number">-1</span>)<span class="keyword">continue</span>;<span class="comment">//如果没找到就结束开始下一次整行读入 </span></span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//找到 </span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//初始化i </span></span><br><span class="line"><span class="keyword">while</span>(s.find(<span class="string">"\"word\": \""</span>,i)!=<span class="number">-1</span>)&#123;<span class="comment">//从i开始一直找"word": " </span></span><br><span class="line"><span class="keyword">int</span> v=s.find(<span class="string">"\""</span>,s.find(<span class="string">"\"word\": \""</span>,i)+<span class="number">10</span>);<span class="comment">//获取汉字右边的双引号 </span></span><br><span class="line"><span class="comment">//if(v-s.find("\"word\": \"",i)-9==8)</span></span><br><span class="line"><span class="comment">//若只需要四字成语请将上面一行的注释去掉即可 </span></span><br><span class="line">O&lt;&lt;s.substr(s.find(<span class="string">"\"word\": \""</span>,i)+<span class="number">9</span>,v-s.find(<span class="string">"\"word\": \""</span>,i)<span class="number">-9</span>)&lt;&lt;<span class="string">" "</span>;<span class="comment">//截取汉字 </span></span><br><span class="line">i=v;<span class="comment">//记得i要往前走，否则会导致死循环 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后输出的应该在<code>data-fixed.txt</code>里面。</p><p>现在我们就有一个成语库了！$($包含非四字成语共$30895$个成语$)$</p><h1 id="2-接龙-AI"><a href="#2-接龙-AI" class="headerlink" title="$2.$接龙$AI$"></a>$2.$接龙$AI$</h1><p>这个很简单，顺便使他会学习，当然这里没有用到什么神经网络之类的，只是用到了每个成语的权值，权值越大代表越难接上，每次接的时候就会选择权值最大的成语去接龙。</p><p>目前由四种情况（人类水平$\le$电脑水平）：</p><ul><li>电脑能接上人类的词：人类的词权值$-1$。</li><li>电脑不能接上人类的词：人类的词权值$+100$，因为当输入时如果人类输入的词在成语库找不到那么电脑不会判定这是一个成语，需要重新输入，所以人类的词必须都在成语库里存在，而电脑接词也是查找成语库，那么如果电脑接不上这个词，就说明这个词很强，所以权值$+100$，到以后如果电脑说这个词人类也会接不出来。</li><li>人类能接上电脑的词：电脑的词权值$-1$</li><li>人类接不上电脑的词（程序中输入<code>awsl</code>）：电脑的词权值$+1$，为什么不$+100$，因为人类水平$\le$电脑水平，玩家接不上不代表电脑接不上。</li></ul><p>权值表在<code>learn.txt</code>中，在<strong>第一次</strong>玩之前必须运行<code>rebuild.exe</code>来创建权值表。若需要清空权值表也可以运行<code>rebuild.exe</code>。</p><p>代码<code>rebuild.cpp</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">O</span><span class="params">(<span class="string">"learn.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30000</span>;i++)O&lt;&lt;<span class="string">"0 "</span>;<span class="comment">//清除或重建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码<code>成语接龙.cpp</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s,now,last;</span><br><span class="line"><span class="keyword">int</span> da;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> chinese;<span class="comment">//成语</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> difficult;<span class="comment">//权值</span></span><br><span class="line">&#125;Data[<span class="number">31000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="comment">//读入成语和权值</span></span><br><span class="line"><span class="built_in">string</span> w;</span><br><span class="line"><span class="function">ifstream <span class="title">I</span><span class="params">(<span class="string">"data-fixed.txt"</span>)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">I2</span><span class="params">(<span class="string">"learn.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(I&gt;&gt;w)&#123;</span><br><span class="line">Data[da].chinese=w;</span><br><span class="line">I2&gt;&gt;Data[da].difficult;</span><br><span class="line">da++;</span><br><span class="line">&#125;</span><br><span class="line">I.close();</span><br><span class="line">I2.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;<span class="comment">//保存权值</span></span><br><span class="line"><span class="function">ofstream <span class="title">O</span><span class="params">(<span class="string">"learn.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31000</span>;i++)O&lt;&lt;Data[i].difficult&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxx=-<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">63</span>),maxn=<span class="number">-1</span>,si,ok;</span><br><span class="line"><span class="comment">/*maxx最大权重 maxn最大权重的成语的下标 si玩家输入的成语在成语库的下标 ok成语是否在成语库里*/</span></span><br><span class="line">read();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入开头成语\n"</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ok=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"你:"</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31000</span>;i++)&#123;<span class="comment">//查找成语是否在成语库里</span></span><br><span class="line"><span class="keyword">if</span>(s==Data[i].chinese)&#123;<span class="comment">//如果有</span></span><br><span class="line">si=i;<span class="comment">//存下标</span></span><br><span class="line">ok=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"AI:"</span>;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">"awsl"</span>)&#123;<span class="comment">//玩家接不上</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"很遗憾，你失败了！"</span>;</span><br><span class="line">Data[maxn].difficult++;</span><br><span class="line">save();<span class="comment">//学习</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!ok)&#123;<span class="comment">//找不到这个成语</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输入错误！\n"</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Data[maxn].difficult--;save();<span class="comment">//合法，接上了电脑的成语，所以学习</span></span><br><span class="line">maxx=-<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">63</span>),maxn=<span class="number">-1</span>;<span class="comment">//初始化，准备找权值最大的成语</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31000</span>;i++)&#123;<span class="comment">//在成语库找</span></span><br><span class="line"><span class="keyword">if</span>(Data[i].chinese.substr(<span class="number">0</span>,<span class="number">2</span>)==s.substr(<span class="number">6</span>,<span class="number">2</span>))&#123;<span class="comment">//前提是要能接上</span></span><br><span class="line"><span class="keyword">if</span>(Data[i].difficult&gt;maxx)&#123;<span class="comment">//取最大值</span></span><br><span class="line">maxx=Data[i].difficult;</span><br><span class="line">maxn=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxn==<span class="number">-1</span>)&#123;<span class="comment">//没有找到，玩家胜利</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"恭喜你，你胜利了！\n"</span>;</span><br><span class="line">Data[si].difficult+=<span class="number">100</span>;</span><br><span class="line">save();<span class="comment">//学习</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Data[si].difficult--;save();<span class="comment">//电脑能接上，学习</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Data[maxn].chinese&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出电脑的词语</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经过多局电脑玩家对决后，$AI$会变得越来越强</p><h1 id="3-自学成才"><a href="#3-自学成才" class="headerlink" title="$3.$自学成才"></a>$3.$自学成才</h1><p>但是，玩家和电脑对决，电脑学习到的只是不多，而且效率慢，所以我们需要电脑自己学习（即自己和自己对决）</p><p>当时$AlphaGo\ Zero$通过自我博弈，仅仅博弈了三天就超过了$AlphaGo$之前训练许久的$Lee$版本，博弈$40$天超过曾打败柯洁的$AlphaGo\ Master$，还发现了新的围棋策略，为围棋这项古老游戏带来了新的见解。</p><p><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b655b6429ecad1c8c4b6f4751e570c6c/0b7b02087bf40ad1e4c2618e5c2c11dfa9eccebd.jpg" alt></p><p><del>说了这么多牛逼的东西，说实在我这个AI进行自我对决还只是老办法赋权值而已</del></p><p>主要思路还是赋权值</p><ul><li>如果$b$接的上$a$，那么$a$权值$-1$</li><li>如果$b$接不上$a$，$a$权值$+1$</li></ul><p>训练方法：</p><ol><li>输入要训练的组数</li><li>每组以一个随机成语开头，然后不断接下去，直到接不下去为止</li><li>学习（赋权值）这轮的结果</li></ol><p><del>现在真的怀疑我这到底是不是人工智能了，我认为这只是一个分辨出哪些词容易接哪些词难接的机器</del></p><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long<span class="comment">//鸡肋的宏定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> chinese;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> difficult;</span><br><span class="line">&#125;Data[<span class="number">31000</span>];</span><br><span class="line"><span class="keyword">int</span> da;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">mt19937 <span class="title">gen</span><span class="params">(time(<span class="number">0</span>))</span></span>;<span class="comment">//随机数种子</span></span><br><span class="line">uniform_int_distribution&lt;&gt;dis(<span class="number">0</span>,<span class="number">30894</span>);<span class="comment">//范围是从0到30894</span></span><br><span class="line"><span class="comment">/*下面开始读取成语库及权值表*/</span></span><br><span class="line"><span class="built_in">string</span> w;</span><br><span class="line"><span class="function">ifstream <span class="title">I</span><span class="params">(<span class="string">"data-fixed.txt"</span>)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">I2</span><span class="params">(<span class="string">"learn.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(I&gt;&gt;w)&#123;</span><br><span class="line">Data[da].chinese=w;<span class="comment">//读入成语</span></span><br><span class="line">I2&gt;&gt;Data[da].difficult;<span class="comment">//权值</span></span><br><span class="line">da++;</span><br><span class="line">&#125;</span><br><span class="line">I.close();</span><br><span class="line">I2.close();</span><br><span class="line"><span class="comment">/*以上是读取数据*/</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入练习次数（请勿在练习中中途关闭）:"</span>;<span class="comment">//如果在中途关闭就是前功尽弃</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++)&#123;<span class="comment">//进行N次练习</span></span><br><span class="line"><span class="keyword">int</span> noi=dis(gen);<span class="comment">//生成一个随机数</span></span><br><span class="line">S now=Data[noi];<span class="comment">//上一个词</span></span><br><span class="line"><span class="comment">//若要显示每局对弈过程，注释掉下面这行</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;"\n/*第"&lt;&lt;i&lt;&lt;"轮*/\n"&lt;&lt;now.chinese&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;<span class="comment">//直到接不了</span></span><br><span class="line"><span class="keyword">int</span> maxx=<span class="number">-1</span>,maxn=<span class="number">0</span>;<span class="comment">//权值最大及下标</span></span><br><span class="line">S maxS;<span class="comment">//权值最大的成语（这个很鸡肋）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31000</span>;i++)&#123;<span class="comment">//寻找能接的成语</span></span><br><span class="line"><span class="keyword">if</span>(now.chinese.substr(now.chinese.size()<span class="number">-2</span>,<span class="number">2</span>)==Data[i].chinese.substr(<span class="number">0</span>,<span class="number">2</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(maxx&lt;Data[i].difficult)&#123;<span class="comment">//找权值最大的</span></span><br><span class="line">maxx=Data[i].difficult;</span><br><span class="line">maxn=i;</span><br><span class="line">maxS=Data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxx==<span class="number">-1</span>)&#123;<span class="comment">//居然接不上</span></span><br><span class="line">Data[noi].difficult++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若要显示每局对弈过程，注释掉下面这行</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;Data[maxn].chinese&lt;&lt;endl;</span></span><br><span class="line">Data[noi].difficult--;<span class="comment">//接的上</span></span><br><span class="line">noi=maxn;<span class="comment">//现在接的成语变成上一个成语</span></span><br><span class="line">now=maxS;<span class="comment">//同上</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ofstream <span class="title">O</span><span class="params">(<span class="string">"learn.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31000</span>;i++)O&lt;&lt;Data[i].difficult&lt;&lt;<span class="string">" "</span>;<span class="comment">//更新权值表</span></span><br><span class="line">O.close();</span><br><span class="line"><span class="comment">//因为权值表在练习完后才更新，所以如果中途关闭就会前功尽弃</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"\n\n\n\n练习完成"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当时，我只用这个训练了$10$分钟，$AI$基本可以$5$步内结束接龙（除非第一个成语就接不上）</p><p>但是，他还是有可能会被玩家打败（不要跟我说你开两个$AI$互打）因为它只会选择最难的成语去接龙，而不会考虑到用这个成语接龙后被反杀的概率。这也是他的一个致命的缺点。</p><h1 id="4-慰问"><a href="#4-慰问" class="headerlink" title="$4.$慰问"></a>$4.$慰问</h1><p>话说要开学了，你们作业写完没啊<del>我还没动过</del></p><hr><script type="math/tex; mode=display">\Huge The\ End.</script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 成语接龙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>趣题：七夕与质数</title>
      <link href="/2019/%E8%B6%A3%E9%A2%98%EF%BC%9A%E4%B8%83%E5%A4%95%E4%B8%8E%E8%B4%A8%E6%95%B0/"/>
      <url>/2019/%E8%B6%A3%E9%A2%98%EF%BC%9A%E4%B8%83%E5%A4%95%E4%B8%8E%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>$By\ King$</p><p>大家都知道，前几天是七夕（其实已经好久了）。我在网上看到一道趣题：</p><blockquote><p>证明：可以将前$520$个素数分成两部分，使得这两部分的差恰等于$521$。</p></blockquote><a id="more"></a><p>证明是不可能的，我们用$01$背包解决这个问题。</p><h1 id="1-计算质数并求和"><a href="#1-计算质数并求和" class="headerlink" title="1.计算质数并求和"></a>1.计算质数并求和</h1><p>我们先计算出前$520$个质数，并将他们求和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> prime[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"2.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);<span class="comment">//质数表存储的地方</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;<span class="number">10000</span>;i+=<span class="number">2</span>)prime[i]=<span class="number">1</span>;<span class="comment">//先筛偶数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;<span class="number">100</span>;i+=<span class="number">2</span>)&#123;<span class="comment">//筛奇数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i&lt;&lt;<span class="number">1</span>;j&lt;<span class="number">10000</span>;j+=i)prime[j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,i=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(cnt!=<span class="number">520</span>)&#123;<span class="comment">//只要前520个</span></span><br><span class="line"><span class="keyword">if</span>(prime[i]==<span class="number">0</span>)&#123;cnt++;<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;&#125;<span class="comment">//输出并累加</span></span><br><span class="line">i++;<span class="comment">//下标加一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>2.txt</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179 2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351 2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423 2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 2593 2609 2617 2621 2633 2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699 2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777 2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857 2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049 3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371 3373 3389 3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527 3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593 3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677 3691 3697 3701 3709 3719 3727</span><br></pre></td></tr></table></figure><p>总和是$897745$。</p><h1 id="2-01-背包"><a href="#2-01-背包" class="headerlink" title="2.$01$背包"></a>2.$01$背包</h1><p>我们用$01$背包来计算这些质数相加都可以得到哪些数字。</p><h2 id="1-证明"><a href="#1-证明" class="headerlink" title="(1)证明"></a>(1)证明</h2><p>然后这个是本文中唯一的数学知识：算出这两组数的总和。</p><p>因为总和是$897745$，那么两组数的和一定是$897745$，列出方程$a+b=897745$。</p><p>然后他们的差是$521$。我们假使$a&gt;b$，那么又列出方程$a-b=521$。</p><p>解出这个方程：$a=449133,b=448612$。</p><p>这个代码检验是否可以有质数相加等于$448612$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> bag[<span class="number">1000000</span>]=&#123;<span class="number">1</span>&#125;;<span class="comment">//记得0是一种放法</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"2.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);<span class="comment">//读入所有质数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">520</span>;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">999999</span>;j&gt;=<span class="number">0</span>;j--)&#123;<span class="comment">//从后面往前枚举</span></span><br><span class="line"><span class="keyword">if</span>(bag[j]==<span class="number">1</span>)bag[j+a]=<span class="number">1</span>;<span class="comment">//放</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;bag[<span class="number">448612</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//检验</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出的是$1$，说明成立</p><h2 id="2-计算"><a href="#2-计算" class="headerlink" title="(2)计算"></a>(2)计算</h2><p>只证明怎么可以呢？像我这种强迫症肯定还要计算出这些数都是什么。</p><p>我们要怎么计算呢？看下面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> bag[<span class="number">1000000</span>]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>],num=<span class="number">448612</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"3.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);<span class="comment">//输出路径</span></span><br><span class="line">freopen(<span class="string">"2.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);<span class="comment">//质数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">520</span>;i++)<span class="built_in">cin</span>&gt;&gt;a[i];<span class="comment">//先读入所有质数</span></span><br><span class="line">KKK:<span class="comment">//goto不要经常用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">520</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">999999</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(bag[j]==<span class="number">1</span>)&#123;</span><br><span class="line">bag[j+a[i]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(j+a[i]==num)&#123;<span class="comment">//如果他是我们要的数</span></span><br><span class="line">num=j;<span class="comment">//记得要减去 等于num-=a[i]</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;<span class="comment">//它就肯定是其中的一个</span></span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//直接结束循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果分解完了结束</span></span><br><span class="line"><span class="built_in">memset</span>(bag,<span class="number">0</span>,<span class="keyword">sizeof</span>(bag));<span class="comment">//初始化</span></span><br><span class="line">bag[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">goto</span> KKK;<span class="comment">//返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>3.txt</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2593 2609 2617 2621 2633 2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699 2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777 2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857 2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049 3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371 3373 3389 3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527 3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593 3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677 3691 3697 3701 3709 3719 89 97 101 103 107 109 113 127 13 11</span><br></pre></td></tr></table></figure><h1 id="3-计算另一部分并检验"><a href="#3-计算另一部分并检验" class="headerlink" title="3.计算另一部分并检验"></a>3.计算另一部分并检验</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ans,a,ans2,ans3,aa,aa2,aa3;<span class="comment">//ans总和 aa个数</span></span><br><span class="line"><span class="keyword">bool</span> t[<span class="number">100000</span>];<span class="comment">//桶</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">I</span><span class="params">(<span class="string">"2.txt"</span>)</span></span>;<span class="comment">//读入质数</span></span><br><span class="line"><span class="keyword">while</span>(I&gt;&gt;a)&#123;t[a]=<span class="number">1</span>;ans3+=a;aa3++;&#125;<span class="comment">//质数置1</span></span><br><span class="line"><span class="function">ifstream <span class="title">I2</span><span class="params">(<span class="string">"3.txt"</span>)</span></span>;<span class="comment">//读入第二组数</span></span><br><span class="line"><span class="keyword">while</span>(I2&gt;&gt;a)&#123;t[a]=<span class="number">0</span>;ans2+=a;aa2++;&#125;<span class="comment">//质数置0</span></span><br><span class="line">freopen(<span class="string">"4.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);<span class="comment">//另一组的路径</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)<span class="keyword">if</span>(t[i])&#123;<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;ans+=i;aa++;&#125;<span class="comment">//如果为1说明没被选中，也就是另一组</span></span><br><span class="line">freopen(<span class="string">"CON"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);<span class="comment">//输出在控制台</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">" "</span>&lt;&lt;ans2&lt;&lt;<span class="string">" "</span>&lt;&lt;ans3&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出总和</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;aa&lt;&lt;<span class="string">" "</span>&lt;&lt;aa2&lt;&lt;<span class="string">" "</span>&lt;&lt;aa3&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>4.txt</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 5 7 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179 2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351 2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423 2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 3727</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">449133 448612 897745</span><br><span class="line">368 152 520</span><br></pre></td></tr></table></figure><p>这是对的！</p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><p>没什么好说的，就证明了<code>可以将前520个素数分成两部分，使得这两部分的差恰等于521。</code></p><p>再发一下这两组数吧：</p><p>第一组数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 5 7 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179 2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351 2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423 2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 3727</span><br></pre></td></tr></table></figure><p>第二组数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 13 89 97 101 103 107 109 113 127 2593 2609 2617 2621 2633 2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699 2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777 2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857 2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049 3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371 3373 3389 3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527 3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593 3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677 3691 3697 3701 3709 3719</span><br></pre></td></tr></table></figure><hr><script type="math/tex; mode=display">\Huge The\ End.</script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 趣题 </tag>
            
            <tag> 01背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何防止游戏存档被篡改</title>
      <link href="/2019/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E8%A2%AB%E7%AF%A1%E6%94%B9/"/>
      <url>/2019/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E8%A2%AB%E7%AF%A1%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<p>$By\ King$</p><p>最近在搞五子棋游戏，加入了一个存档的功能。但是游戏存档很容易被篡改，接下来我们讲一讲如何防止游戏存档被篡改。</p><a id="more"></a><h1 id="1-文件位置"><a href="#1-文件位置" class="headerlink" title="1.文件位置"></a>1.文件位置</h1><p>很多单机游戏都会直接把游戏存档存在与游戏的同文件夹中（之前$RioBlu$做的<code>统一天下</code>就是这样，<del>就像给篡改者看的一样</del>）</p><p>所以我们可以将文件存在像$C$盘啊，$D$盘这些的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">O</span><span class="params">(<span class="string">"C:\\2005czq.github.io"</span>)</span></span>;</span><br><span class="line">O&lt;&lt;a;</span><br></pre></td></tr></table></figure><p>但是这个可能有一些缺陷，有些电脑是没有$D$盘这些的，而且如果用户强制删除的时候他根本不会在意你存档存在哪个位置，直接把你<code>exe</code>文件删了。这样就会有文件残留。</p><p>当然你也可以跟用户说一下。</p><h1 id="2-隐藏文件"><a href="#2-隐藏文件" class="headerlink" title="2.隐藏文件"></a>2.隐藏文件</h1><p>我们可以隐藏文件使篡改者找不到文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetFileAttributes(<span class="string">"2005czq.github.io"</span>,FILE_ATTRIBUTE_HIDDEN);<span class="comment">//隐藏</span></span><br><span class="line">SetFileAttributes(<span class="string">"2005czq.github.io"</span>,FILE_ATTRIBUTE_NORMAL);<span class="comment">//取消隐藏</span></span><br></pre></td></tr></table></figure><p>以上语句对文件夹也可以用。</p><p>缺陷：电脑可以通过<code>工具-文件夹选项-查看-高级设置</code>里显示所有被隐藏的文件。</p><p><strong>注意：当文件被隐藏时，程序还是可以对文件进行<code>DeleteFile</code>和<code>ifstream</code>操作，但如果要执行<code>ofstream</code>操作，需要先将文件删除</strong></p><h1 id="3-加密"><a href="#3-加密" class="headerlink" title="3.加密"></a>3.加密</h1><p>最好的方法肯定是加密了。</p><h2 id="1-我自己常用的"><a href="#1-我自己常用的" class="headerlink" title="(1)我自己常用的"></a>(1)我自己常用的</h2><ul><li>在<code>中国象棋 抗日战争</code>里面：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r=rand(),r2=rand();<span class="comment">//产生两个随机数</span></span><br><span class="line">r2+=r;</span><br><span class="line">O&lt;&lt;r*r*r&lt;&lt;<span class="string">" "</span>&lt;&lt;r2*r2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)O&lt;&lt;table[i][j]*table[i][j]+r2&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">O&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L_len;i++)</span><br><span class="line">O&lt;&lt;Line[i].x1-r&lt;&lt;<span class="string">" "</span>&lt;&lt;Line[i].y1+r&lt;&lt;<span class="string">" "</span>&lt;&lt;Line[i].x2-r2&lt;&lt;<span class="string">" "</span>&lt;&lt;Line[i].y2+r2&lt;&lt;<span class="string">" "</span>&lt;&lt;Line[i].eat*<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><p>因为当时游戏不是很出名<del>（反正现在也是）</del>，所以加密算法用的不是特别好。</p><ul><li><code>五子棋</code>里面的：这里不公开代码了，大概是随机生成一个数，然后用它异或一个数后的数存出存档，然后以后的数据都是通过这个秘钥得出。而且！存档存出去后是一张图片！</li></ul><h2 id="2-其他加密算法"><a href="#2-其他加密算法" class="headerlink" title="(2)其他加密算法"></a>(2)其他加密算法</h2><p>只要你能想到的都可以，例如$MD5$、$SHA256$，这些算法安全度很高，如果你只是编个小游戏，可以自己设计加密算法。</p><h2 id="3-如何将存档变成图片"><a href="#3-如何将存档变成图片" class="headerlink" title="(3)如何将存档变成图片"></a>(3)如何将存档变成图片</h2><p>其实这个十分简单，百度也是可以找到的。</p><p>就是将数据存为<code>ppm</code>文件（一种<code>Linux</code>的图片格式），这种文件的存储方式十分简单：</p><blockquote><p>P3 图片长 图片宽 255<br>接下来 图片长*图片宽 个像素点<br>每个像素点RGB值三个值：R G B（每个值在0到255之间）</p></blockquote><p>例如下面就是一个：</p><blockquote><p>P3 2 2 255<br>255 255 255<br>102 204 255<br>57 197 187<br>0 0 0</p></blockquote><p>也可以把所有数压在一行。<br>我们可以将它看成$256$进制数，那么每个像素点最多可以存$0$到$255\times65536+255\times256+255=2^{24}-1$的数。</p><p>如果你要储存的数据个数是质数个，可以添加几个随机数在里面。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">O</span><span class="params">(<span class="string">"1.ppm"</span>)</span></span>;</span><br><span class="line">O&lt;&lt;<span class="string">"P3 "</span>&lt;&lt;h&lt;&lt;<span class="string">" "</span>&lt;&lt;w&lt;&lt;<span class="string">" 255"</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++)</span><br><span class="line">O&lt;&lt;<span class="string">" "</span>&lt;&lt;a[i][j].r&lt;&lt;<span class="string">" "</span>&lt;&lt;a[i][j].g&lt;&lt;<span class="string">" "</span>&lt;&lt;a[i][j].b;</span><br></pre></td></tr></table></figure></p><p>我们可以用类似的方法，将数据储存为<code>wav</code>文件（因为这个咕咕了所以以后有时间再说）</p><h2 id="4-玄学大法"><a href="#4-玄学大法" class="headerlink" title="(4)玄学大法"></a>(4)玄学大法</h2><p>在我编<code>中国象棋 抗日战争</code>的时候，由于要存中文，然后$RioBlu$给我介绍了一种加密大法（只适用全角符号，如果有半角符号这个加密将很弱）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"我卢本伟没有开挂"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)O&lt;&lt;s[i]&lt;&lt;<span class="string">" "</span>;</span><br></pre></td></tr></table></figure></p><p>当你运行程序的时候你看存档会发现都是一堆乱码似的东西，这是因为你把全角符号拆成两份，就会变成乱码，但是还是可以读入的！<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> v=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">char</span> ch=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span>(I&gt;&gt;ch)v+=ch;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v;</span><br></pre></td></tr></table></figure></p><p>我觉得这种方法挺不错，而且当我用了这个方法后<del>也不知道为什么</del>，只要你一改存档，整个棋盘就会变成乱码，无论你改什么，而且如果你改回来，他还是乱码。<br><a href="https://share.weiyun.com/5KyEqcF" target="_blank" rel="noopener">体验一下</a>（密码<code>iloveu</code>，存档在同文件夹的<code>chess\data\</code>里面，文件都隐藏了）</p><h1 id="4-读取判断"><a href="#4-读取判断" class="headerlink" title="4.读取判断"></a>4.读取判断</h1><p>在读取的时候加入判断，如果读取的信息和游戏设定不符合（例如金币是负数），那么直接删除存档。</p><p>$RioBlu$的<code>统一天下</code>也是这样，当读入的数据为负数（数字太大会溢出变成负数），就会运行一些恶意代码卡电脑（这样子好像不太好<del>但谁叫你改我存档</del>）。</p><h1 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h1><p>当你完成后，你就当一回“熊孩子”，测试自己的存档会不会很容易被篡改。</p><p>你也可以叫上你的好朋友们一起测试。</p><h1 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h1><p>只要你能很好地将上面几点做好，我相信你的存档不会被篡改。</p><hr><script type="math/tex; mode=display">\Huge The\ End.</script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>趣题：定义正整数P，使得2到N的数字都整除不了P</title>
      <link href="/2019/%E8%B6%A3%E9%A2%98%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%AD%A3%E6%95%B4%E6%95%B0P%EF%BC%8C%E4%BD%BF%E5%BE%972%E5%88%B0N%E7%9A%84%E6%95%B0%E5%AD%97%E9%83%BD%E6%95%B4%E9%99%A4%E4%B8%8D%E4%BA%86P/"/>
      <url>/2019/%E8%B6%A3%E9%A2%98%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%AD%A3%E6%95%B4%E6%95%B0P%EF%BC%8C%E4%BD%BF%E5%BE%972%E5%88%B0N%E7%9A%84%E6%95%B0%E5%AD%97%E9%83%BD%E6%95%B4%E9%99%A4%E4%B8%8D%E4%BA%86P/</url>
      
        <content type="html"><![CDATA[<p>$By\ RioBlu$</p><p>可不可以定义正整数$P$，使得$2$～$N$的数字都整除不了$P$?</p><a id="more"></a><p>其实方法有很多，我先讲一个非常个简单的</p><h2 id="P-N-1"><a href="#P-N-1" class="headerlink" title="$P=N!+1$"></a>$P=N!+1$</h2><p>P除$2$到$n$的数都会余一，太棒了!</p><p>这肯定十分精简</p><p>不不不，精简的还在下面</p><p>再看看一个比较精简的</p><h2 id="P-比-N-大任意一个质数"><a href="#P-比-N-大任意一个质数" class="headerlink" title="$P=$比$N$大任意一个质数"></a>$P=$比$N$大任意一个质数</h2><p>一个比$N$大的质数，怎么可能会整除$2$～$N$的数字呢</p><p>的确这也非常巧妙，但这种定义会在同一个$N$下出现多个答案，如果说每一个$N$只有一个答案，就应该改成<strong>$P$=比$N$大且最小的质数</strong></p><p>但也有不少人会想得十分复杂</p><p>看看这位童鞋</p><h2 id="P-所有小于等于-N-的质数的积-1"><a href="#P-所有小于等于-N-的质数的积-1" class="headerlink" title="P=所有小于等于$N$的质数的积$+1$"></a>P=所有小于等于$N$的质数的积$+1$</h2><p>那么$P除$2$～$N$中的质数质数必余一，即不能整除</p><p>那，那些合数呢？</p><p>合数也很好解释，你说一个数不能整除$2$了，它还能整除$6$吗？</p><p>比如$N=7$</p><p>$P=2\times3\times5\times7+1=211$</p><p>你说$P\mod2$不等于$0$，$P\mod3$不等于$0$</p><p>那么$6=2\times3$，怎么可能$P\mod6=0$呢？</p><p>哦!不过这个思想有点难懂啊，没有之前的那么简单</p><p>确实，不过这是第一种的升级版，比第一个来说，小上了一些，对于那些编程的来说，小一点总是好事，这样便可以不打万恶的高精度乘法了</p><p>最后，我们来说说重头戏</p><h2 id="P-1"><a href="#P-1" class="headerlink" title="$P=1$"></a>$P=1$</h2><p>我和我的小伙伴们都惊呆了!</p><p>这是哪门子的方法，不过仔细回味一下，确实，这是对的</p><p>我们思考了这么久，被一个$P=1$解决了，简单明了</p><p>所以，在做一些题是可以投机取巧的，不过小心，聪明反被聪明误哦</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整除 </tag>
            
            <tag> 质数 </tag>
            
            <tag> 趣题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何找单峰函数峰值</title>
      <link href="/2019/%E5%A6%82%E4%BD%95%E6%89%BE%E5%8D%95%E5%B3%B0%E5%87%BD%E6%95%B0%E5%B3%B0%E5%80%BC/"/>
      <url>/2019/%E5%A6%82%E4%BD%95%E6%89%BE%E5%8D%95%E5%B3%B0%E5%87%BD%E6%95%B0%E5%B3%B0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>$By\ King$</p><p>找单峰函数的峰值有什么用？ 怎么找单峰函数的峰值？</p><p>别急，让这篇文章来告诉你。</p><a id="more"></a><h1 id="1-什么是单峰函数？"><a href="#1-什么是单峰函数？" class="headerlink" title="$1.$什么是单峰函数？"></a>$1.$什么是单峰函数？</h1><p>肯定要先听听度娘的解释啦！</p><blockquote><p>单峰函数是在所考虑的区间中只有一个严格局部极大值$($峰值$)$的实值函数。如果函数$f(x)$在区间$[a, b]$上只有唯一的最大值点$C$，而在最大值点$C$的左侧，函数单调增加；在点$C$的右侧，函数单调减少，则称这个函数为区间$[a, b]$上的单峰函数。——<a href="https://baike.baidu.com/item/%E5%8D%95%E5%B3%B0%E5%87%BD%E6%95%B0/7544838?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p></blockquote><p>引用百度的原图大概的说一下：</p><p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=9e52f76d4036acaf4ded9eae1db0e675/0824ab18972bd407604767a970899e510eb309e5.jpg" alt></p><p>就是函数$f(x)$有一个最高点$x_0$（如图），然后它的右边单调下降，左边单调上升。</p><p>也可以这样解释：</p><p>如果$f(x)$最大：</p><ul><li>如果$a&lt;b&lt;x$，那么$f(b)\ge f(a)$。</li><li>如果$x&gt;a&gt;b$，那么$f(a)\ge f(b)$。</li></ul><hr><p>寻找一个单峰函数的峰值有什么用？</p><ul><li>某些$OI$题会让你求一个单峰函数的峰值，例如<a href="http://poj.org/problem?id=2420" target="_blank" rel="noopener">POJ2420</a>、<a href="http://poj.org/problem?id=3737" target="_blank" rel="noopener">POJ3737</a>、<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2340" target="_blank" rel="noopener">ZOJ2340</a>等。甚至洛谷还有一道<a href="https://www.luogu.org/problem/P3382" target="_blank" rel="noopener">模板题</a>。</li><li>生活中的很多东西都是这样，大了也不好，小了也不好，不多不少的时候最好。我最喜欢举的例子是，粉笔短了不好写且用得快，粉笔长了又容易断；为了贯彻拿$MM$打比方的精神，这里可以再举一些例子来说明这一情况的普遍性：陪$MM$出去玩的次数多了很快会腻，陪$MM$次数少了又会疏远；把握火候贯彻“半糖主义”方针是非常重要的。事实上，从硬盘缓存的大小到初期农民的个数，从每学期的学分到论文的长度，生活中几乎所有东西都是这样，就连饭量和睡眠时间也是。这些例子说穿了就是一个单峰函数，我们需要用尽可能少的试验次数快速找到极大点。永远不要以为决策者们面对的都是高中数学考卷上的“每涨$10$块钱就会少$100$个消费者”一类的屁话，这些屁话都是用来编二次函数题目的。现实生活中企业做决策时，样点实验、不断取舍、逐步逼近最优点仍然是最实在最有效的手段。——$Matrix67$</li><li>奥数题，这是真的。<del>只要那是填空题</del></li></ul><h1 id="2-怎么找单峰函数的峰值？"><a href="#2-怎么找单峰函数的峰值？" class="headerlink" title="$2.$怎么找单峰函数的峰值？"></a>$2.$怎么找单峰函数的峰值？</h1><h2 id="0-注意"><a href="#0-注意" class="headerlink" title="$(0)$注意"></a>$(0)$注意</h2><p>本节中以$f(x)$为代码中的单峰函数。左端点和右端点为$0$和$10$。</p><p>这里使用$f(x)=\sqrt[x]{x}$。$f(x)$峰值为$\sqrt[e]{e}$，约等于$1.444667861$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(x,<span class="number">1</span>/x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-暴力枚举"><a href="#1-暴力枚举" class="headerlink" title="$(1)$暴力枚举"></a>$(1)$暴力枚举</h2><p>最普通的方法肯定是暴力啦！</p><p>这个不用说了吧，设置步长，从左到右扫记录最大值。</p><p><strong>优点：相对稳定。</strong></p><p><strong>缺点：耗时长，精度低。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pre=<span class="number">2</span>;<span class="comment">//精度可调</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p=<span class="built_in">pow</span>(<span class="number">10</span>,-pre);<span class="comment">//计算步长</span></span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">10</span>,maxx=<span class="number">-1</span>;<span class="comment">//看情况来定maxx的初始值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> i=l+pre;i&lt;=r;i+=p)<span class="comment">//由于使用x^(1/x)为f函数，所以i不能为0</span></span><br><span class="line">    maxx=max(maxx,f(i));<span class="comment">//寻找最大值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(10^n)$，照着这样，$1$秒只能算到$7$位数左右。</p><h2 id="2-三分查找-1"><a href="#2-三分查找-1" class="headerlink" title="$(2)$三分查找$1$"></a>$(2)$三分查找$1$</h2><p>像这种带有单调性的函数，让人不由自主的想起——二分。</p><p>但是我们不能只取一个点，因为这是无法得出峰值在哪里的，所以我们需要取两个点，通过比较这两个点来得出峰值的位置。</p><p><del>俩学家</del>阮大佬曾在<a href="http://ruanx.pw/post/%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE.html" target="_blank" rel="noopener">他的博客</a>中介绍了三分查找，主要是分一半再分一半的思想（$mid$是$l$和$r$的中点，$mmid$是$mid$和$r$的中点）。如图：</p><p><img src="https://s2.ax1x.com/2019/07/25/em1eud.png" alt></p><p>比较$f(mid)$和$f(mmid)$的值：</p><ul><li>当$f(mid)&gt;f(mmid)$的值时，使$r=mmid$。即峰值必在$midd$左边。</li><li>当$f(mid)&lt;f(mmid)$时，使$l=mid$。即峰值必在$mid$右边。</li></ul><p>证明在链接里有，这里就照着我的思路再讲一遍吧（其实是差不多的）：</p><p>当$f(mid)&gt;f(mmid)$的值时，若峰值在$midd$右边，会导致有$2$个峰（否则$f(mid)$不会大于$f(mmid)$），所以峰值必在$midd$左边。</p><p>同样可以证第二个。</p><p>既然这样，我们就可以进行三分，每次可以舍去原长度的$\frac{1}{2}$或$\frac{1}{4}$。</p><p>那么时间复杂度最优$O(2\log_2n)$，最坏$O(2\log_\frac{4}{3}n)$。</p><p>另外，在链接里有提及到写法，一种是<code>控制迭代次数</code>，一种是<code>直接控制精度</code>，接下来的本节的代码都是<code>直接控制精度</code>。</p><p><strong>优点：速度快。</strong></p><p><strong>缺点：不稳定。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pre=<span class="number">10</span>;<span class="comment">//设置精度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> p=<span class="built_in">pow</span>(<span class="number">10</span>,-pre);<span class="comment">//计算精度限制</span></span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">10</span>,mid,mmid;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;p)&#123;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;<span class="comment">//计算mid</span></span><br><span class="line">        mmid=(mid+r)/<span class="number">2</span>;<span class="comment">//计算mmid</span></span><br><span class="line"><span class="keyword">if</span>(f(mid)-f(mmid)&gt;=<span class="number">0</span>)r=mmid;<span class="comment">//大于时舍去右边</span></span><br><span class="line"><span class="keyword">if</span>(f(mid)-f(mmid)&lt;=<span class="number">0</span>)l=mid;<span class="comment">//小于时舍去左边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;max(f(l),f(r));<span class="comment">//输出更大的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有一个问题：</p><p>代码中$10$到$11$行中，照着思路来说，应该是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f(mid)-f(mmid)&gt;<span class="number">0</span>)r=mmid;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br></pre></td></tr></table></figure><p>为什么要换成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f(mid)-f(mmid)&gt;=<span class="number">0</span>)r=mmid;</span><br><span class="line"><span class="keyword">if</span>(f(mid)-f(mmid)&lt;=<span class="number">0</span>)l=mid;</span><br></pre></td></tr></table></figure><p>因为我在测试的过程中，发现若换成带<code>else</code>的代码，那么当$pre&gt;15$的时候，由于$C++$的精度问题会将$\frac{x+r}{2}$的值算成$l$（$x$很接近$l$），那么就会算出$mid=l$，然后又算出$mmid=l$。那么$mid=mmid$就算出了$f(mid)-f(mmid)$等于$0$，那么就会执行<code>else</code>后的语句$l=mid$，然而$mid$本来就等于$l$，也就是说什么都没有变，最终导致了死循环。</p><p>另外，我们并没有提到过当$f(mid)=f(midd)$时的情况，因为在此时峰值三种情况都有可能（如图），所以只能靠“蒙”。</p><p><img src="https://s2.ax1x.com/2019/07/26/entjhR.png" alt><br>然而度娘告诉我们：我们应该“蒙”中间，也就是说把左右都去掉（如图）：</p><p><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=07ed2748514e9258b2398ebcfdebba3d/8718367adab44aed20bd71c8b41c8701a18bfb2f.jpg" alt></p><p>于是就有了这样一段代码。</p><h2 id="3-三分查找-2"><a href="#3-三分查找-2" class="headerlink" title="$(3)$三分查找$2$"></a>$(3)$三分查找$2$</h2><p>为了让算法变得更稳定，我们可以把这两个点设在三等分处，这样每次都一定会舍弃原长度的$\frac{1}{3}$。时间复杂度$O(2log_3n)$。</p><p><img src="https://s2.ax1x.com/2019/07/26/en0hh4.png" alt></p><p><strong>优点：速度快，相对更稳定。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pre=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> p=<span class="built_in">pow</span>(<span class="number">10</span>,-pre);</span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">10</span>,m1,m2;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;p)&#123;</span><br><span class="line">        m1=(l+r+l)/<span class="number">3</span>;</span><br><span class="line">        m2=(l+r+r)/<span class="number">3</span>;<span class="comment">//这两句需要注意！！！</span></span><br><span class="line"><span class="keyword">if</span>(f(m1)-f(m2)&gt;=<span class="number">0</span>)r=m2;</span><br><span class="line"><span class="keyword">if</span>(f(m1)-f(m2)&lt;=<span class="number">0</span>)l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;max(f(l),f(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中有一处是需要注意的。</p><p><strong>千万不要写成m1=(l+r)3和m2=(l+r)2/3！！</strong></p><p>很多人认为二分时$m=\frac{1}{2}(l+r)$，然而自然就想到三分是应该是$\frac{1}{3}(l+r)$和$\frac{2}{3}(l+r)$</p><p>这样写是错误的，例如$l=3,r=4$的时候$m1=\frac{7}{3}=2.333\dots,m2=\frac{14}{3}=4.666\dots$。根本不在$l$和$r$的范围内！</p><p>因为我们截取的是一段，所以原长度的$\frac{1}{3}$应该是$\frac{r-l}{3}$，也就是说$m1$应该是$l+\frac{r-l}{3}=\frac{2l+r}{3}$，$m2=r-\frac{r-l}{3}=\frac{2r+l}{3}$。</p><p>那为什么二分是$m=\frac{l+r}{2}$？</p><p>其实也是一样的道理，$m=l+\frac{r-l}{2}=\frac{l+r}{2}$。</p><h2 id="4-“二分查找”"><a href="#4-“二分查找”" class="headerlink" title="$(4)$“二分查找”"></a>$(4)$“二分查找”</h2><p>我们发现只要$m1$到$l$的距离和$m2$的到$r$距离相等，算法就会稳定。如果我们想需要速度更快，应该怎么处理呢？</p><p>可以想到我们如果把$m1$和$m2$取得接近于中点，那么一次比较就可以舍去几乎$\frac{1}{2}$的长度了！</p><p>如图中（$C$是一个较小的常数）：<br><img src="https://s2.ax1x.com/2019/07/26/enBvZV.png" alt></p><p><strong>优点：速度比普通三分快</strong></p><p><strong>缺点：语言浮点运算误差必须小</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pre=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> p=<span class="built_in">pow</span>(<span class="number">10</span>,-pre);</span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">10</span>,m;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;=p)&#123;</span><br><span class="line">m=(l+r)/<span class="number">2</span>;<span class="comment">//取中点 </span></span><br><span class="line"><span class="keyword">if</span>(f(m-p)-f(m+p)&gt;=<span class="number">0</span>)r=m;</span><br><span class="line"><span class="keyword">if</span>(f(m-p)-f(m+p)&lt;=<span class="number">0</span>)l=m;<span class="comment">//比较中点两端 </span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;max(f(l),f(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：如果常数$C$太小，那么$C++$就会将$mid-C$和$mid+C$看作相等，然后$l=mid,r=mid$，然后结束循环，最终你得到的答案只是$f(mid)$的值。</strong></p><p>时间复杂度大约是$O(\log_2n)$。</p><h2 id="5-求导-二分"><a href="#5-求导-二分" class="headerlink" title="$(5)$求导$+$二分"></a>$(5)$求导$+$二分</h2><p>为什么可以这样做？</p><p>如果你学过高中数学，你会知道导数的零点就是原函数的峰值。</p><p>因为是单峰，所以只需要找$l$和$r$之间的使$f(x)$为$0$的数。</p><p>那么问题就转化成了二分</p><p>做法：</p><p>首先，你需要先对函数<a href="https://baike.baidu.com/item/%E5%AF%BC%E6%95%B0%E8%A1%A8/10889755#1" target="_blank" rel="noopener">求导</a>。</p><p>个人不太支持这种，毕竟复杂的函数很难求导，如果是多项式求导就比较简单一些，直接用幂函数求导公式。</p><script type="math/tex; mode=display">a_0+a_1x+a_2x^2+\dots+a_{n-1}x^{n-1}+a_nx^n</script><p>求导后是</p><script type="math/tex; mode=display">a_1+2a_2x+3a_3x^2+\dots+na_nx^{n-1}</script><p><strong>优点：用着舒服，基本不会出$bug$</strong></p><p><strong>缺点：复杂函数难求导</strong></p><p>这里给出<a href="https://www.luogu.org/problem/P3382" target="_blank" rel="noopener">P3382 【模板】三分法</a>的求导$+$二分的代码（$\sqrt[x]{x}$求导太难了<del>其实是不会</del>）</p><p>因为懒，我这里直接放出<a href="https://www.luogu.org/space/show?uid=100514" target="_blank" rel="noopener">小黑AWM大佬</a>的<a href="https://andrewwayne.blog.luogu.org/solution-p3382" target="_blank" rel="noopener">题解</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">20</span>],L,R,k;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) ans=ans*x+a[i];<span class="comment">//常数项没了</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lf%lf"</span>,&amp;n,&amp;L,&amp;R);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;i--)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i]),a[i]*=i;<span class="comment">//a[i]*=i求导</span></span><br><span class="line"><span class="keyword">while</span>(R-L&gt;=<span class="number">1e-6</span>)&#123;<span class="comment">//二分</span></span><br><span class="line"><span class="keyword">double</span> mid=(R+L)/<span class="number">2</span>;</span><br><span class="line">    f(mid)&gt;<span class="number">0</span>?L=mid:R=mid;<span class="comment">//等价于if(f(mid)&gt;0)L=mid;else R=mid;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>,L);<span class="comment">//输出答案</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-0-618-法"><a href="#6-0-618-法" class="headerlink" title="$(6)0.618$法"></a>$(6)0.618$法</h2><p>然而这些做法都不能很好地优化。（除了求导二分）</p><p>最好的做法是循环利用上一次比较时剩下的点。使一个点被去掉后另一个点正好是下一次比较的其中一个点。这就是<a href="https://baike.baidu.com/item/0.618%E6%B3%95/7238973?fr=aladdin" target="_blank" rel="noopener">$0.618$法</a>，是<a href="https://baike.baidu.com/item/%E4%BC%98%E9%80%89%E6%B3%95/3111033?fr=aladdin" target="_blank" rel="noopener">优选法</a>的其中一种。</p><p>那么这两个点应该取在哪里呢？</p><p>$A$点在$B$点去掉后的那一段上的位置与$B$点原先在整段上所处的位置比例相同,那么这个比例通过计算得出：<br><img src="https://s2.ax1x.com/2019/07/26/enWnF1.png" alt></p><p>$\frac{a}{b}$约等于$0.618$。</p><p>那么$a=\frac{r-l}{1+\frac{1+\sqrt{5}}{2}}$，也就是是$\frac{r-l}{\phi+1}$。</p><p>这样，我们就确定了两个点的位置了。</p><p><strong>优点：重复利用测试点，速度极快。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 0.38196601125010515179541316563436<span class="comment">//1-φ</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pre=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> p=<span class="built_in">pow</span>(<span class="number">10</span>,-pre);</span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">10</span>,m1=l+F*(r-l),m2=r-F*(r-l);</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;p)&#123;</span><br><span class="line"><span class="keyword">if</span>(f(m1)&gt;=f(m2))&#123;</span><br><span class="line">r=m2;<span class="comment">//去掉右边</span></span><br><span class="line">m2=m1;<span class="comment">//替换</span></span><br><span class="line">m1=l+F*(r-l);<span class="comment">//计算新的m1</span></span><br><span class="line"><span class="keyword">if</span>(f(m1)&gt;f(m2))<span class="keyword">continue</span>;<span class="comment">//如果等于先不要结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f(m1)&lt;=f(m2))&#123;</span><br><span class="line">l=m1;<span class="comment">//去掉左边</span></span><br><span class="line">m1=m2;<span class="comment">//替换</span></span><br><span class="line">m2=r-F*(r-l);<span class="comment">//计算新的m2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;f(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-本节小结"><a href="#7-本节小结" class="headerlink" title="$(7)$本节小结"></a>$(7)$本节小结</h2><h3 id="I-哪种算法更好？"><a href="#I-哪种算法更好？" class="headerlink" title="$I.$哪种算法更好？"></a>$I.$哪种算法更好？</h3><p>应该是$0.618$法了。</p><p>如果说函数比较方便求导，那肯定推荐求导二分，毕竟只需要$log_2n$的时间。</p><p>附带一张图关于以上的算法的速度（没有写求导二分）：</p><p>$\color{orange}{暴力枚举}\color{black}{、}\color{purple}{三分查找1}\color{black}{、}\color{green}{三分查找2}\color{black}{、}\color{blue}{“二分查找”}\color{black}{、}\color{red}{0.618法}$</p><p><img src="https://s2.ax1x.com/2019/07/30/eGOJtH.png" alt></p><p>$Draw\ by\ GeoGebra$</p><h3 id="II-其他玄学的方法"><a href="#II-其他玄学的方法" class="headerlink" title="$II.$其他玄学的方法"></a>$II.$其他<del>玄学的</del>方法</h3><p>直接看<a href="https://www.luogu.org/problemnew/solution/P3382" target="_blank" rel="noopener">P3382的题解</a>你就会发现有很多玄学大法：什么<a href="https://www.luogu.org/blog/yuy/solution--p3382" target="_blank" rel="noopener">粒子群优化</a>啊、<a href="https://www.luogu.org/blog/Hakuryu/p3382-san-fen-fa-mu-ni-tui-huo" target="_blank" rel="noopener">模拟退火</a>啊、<a href="https://ouuan.blog.luogu.org/solution-p3382" target="_blank" rel="noopener">梯度下降法</a>啊、甚至还出现了<a href="https://youngsc.blog.luogu.org/solution-p3382" target="_blank" rel="noopener">四分</a>。</p><h3 id="III-小优化"><a href="#III-小优化" class="headerlink" title="$III.$小优化"></a>$III.$小优化</h3><p>若题目要求多项式的峰值，可以通过<a href="https://baike.baidu.com/item/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95/449196?fr=aladdin" target="_blank" rel="noopener">秦九韶算法</a>简化多项式，从而使效率更高。</p><p>多项式$a_0+a_1x+a_2x^2+a_3x^3+\dots+a_nx^n$，若直接计算，则需要进行$\frac{n(n+1)}{2}$乘法和$n$次加法。</p><p>但是我们学过乘法分配律，你会发现除$a_0$项外每项都带有$x$，那么分配起来：$a_0+x(a_1+a_2x+a_3x^2+\dots+a_nx^{n-1})$</p><p>在括号内除$a_1$项外都含有$x$，再次分配：$a_0+x(a_1+x(a_2+a_3x+\dots+a_nx^{n-2}))$</p><p>以此类推，最后就会变成：$a_0+x(a_1+\dots+x(a_{n-2}+x(a_{n-1}+a_nx)))$。这个式子最终只需要进行$n$次乘法和$n$次加法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">ans+=a[i]*<span class="built_in">pow</span>(x,i);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="comment">//普通算法</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)ans=ans*x+a[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="comment">//秦九韶算法</span></span><br></pre></td></tr></table></figure><h1 id="3-例题"><a href="#3-例题" class="headerlink" title="$3.$例题"></a>$3.$例题</h1><h2 id="1-原创题目"><a href="#1-原创题目" class="headerlink" title="$(1)$原创题目"></a>$(1)$原创题目</h2><p>题意：给你一张边长为$n$的正方形纸，在四个角落各剪一个边长为$x$的小正方形$(0&lt;x&lt;\frac n2)$，拼成一个无盖长方体，请输出这个长方体体积最大时的体积、高和底面正方形的边长（保留$5$位小数）。</p><p><img src="https://s2.ax1x.com/2019/07/30/eJJYIP.png" alt></p><p>我们知道，它的体积是$x(n-2x)^2$，可以知道当$x=0$和$x=\frac n2$时体积为$0$（还有一个$x=\frac n2$是<a href="https://baike.baidu.com/item/%E9%87%8D%E6%A0%B9/5030500?fr=aladdin" target="_blank" rel="noopener">重根</a>），那么$0$到$\frac n2$之间一定只有一个峰。类似下图：</p><p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=39b5a4918b0a19d8df0e8c575293e9ee/cc11728b4710b9123df60bdec8fdfc03924522df.jpg" alt></p><p>所以可以用三分，三分$x$的长度（即三分盒子的高）。</p><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> n,l,r,m1,m2;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*(n<span class="number">-2</span>*x)*(n<span class="number">-2</span>*x);<span class="comment">//返回体积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">r=n/<span class="number">2.0</span>;<span class="comment">//题目说了x&lt;n/2</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1e-7</span>)&#123;</span><br><span class="line">        m1=(l+r+l)/<span class="number">3</span>;</span><br><span class="line">        m2=(l+r+r)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(f(m1)-f(m2)&gt;=<span class="number">0</span>)r=m2;</span><br><span class="line"><span class="keyword">if</span>(f(m1)-f(m2)&lt;=<span class="number">0</span>)l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">5</span>)&lt;&lt;f(l)&lt;&lt;<span class="string">" "</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="built_in">sqrt</span>(f(l)/l);<span class="comment">//a*a*h=f(h)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你测试几个测试点的时候，你就会发现答案似乎是一些循环小数。</p><p>确实是这样，这里是公式$V=\frac{2n^3}{27},h=\frac n6,a=\frac{2n}{3}$，所以：</p><p><del>正解</del>就有另一种解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">5</span>)&lt;&lt;<span class="number">2</span>*n*n*n/<span class="number">27</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;n/<span class="number">6</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="number">2</span>*n/<span class="number">3</span>;<span class="comment">//直接套用公式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-POJ3737-UmBasketella"><a href="#2-POJ3737-UmBasketella" class="headerlink" title="$(2)$POJ3737-UmBasketella"></a>$(2)$POJ3737-UmBasketella</h2><p>题意：输入圆锥表面积$S$，输出其最大体积，以及此时圆锥的高和底面半径。</p><p>先证明它是单峰函数（只看正数部分）：</p><p><img src="https://s2.ax1x.com/2019/07/27/eKTW5D.png" alt></p><p>$Draw\ by\ $<a href="https://www.geogebra.org/graphing/jtehwrxe" target="_blank" rel="noopener">$GeoGebra$</a></p><p>这只是其中的$S=1$的情况<del>我也不会证只是给你们看一下知道是就行</del></p><p>圆锥表面积公式：$S=\pi r(r+\sqrt{r^2+h^2})$</p><p>圆锥体积公式：$V=\frac{1}{3}\pi r^2h$</p><p>知道这些后，就可以开始三分了。</p><p>做法：三分$r$的值。通过表面积$S$和$r$计算出$h$的值，再通过$r$和$h$计算出圆锥的体积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;//poj不给用万能头QAQ</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI acos(-1)</span></span><br><span class="line"><span class="comment">/*上面这句其实可以不加，因为math.h里有，但如果不加在poj就会CE*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> S,V,H;<span class="comment">//表面积，体积，高</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> R)</span></span>&#123;</span><br><span class="line">H=<span class="built_in">sqrt</span>((S/(M_PI*R)-R)*(S/(M_PI*R)-R)-R*R);<span class="comment">//通过表面积和底面半径算出高</span></span><br><span class="line">V=M_PI*R*R*H/<span class="number">3</span>;<span class="comment">//先存到V里</span></span><br><span class="line"><span class="keyword">return</span> V;<span class="comment">//返回体积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;S)&#123;<span class="comment">//有多个数据</span></span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="built_in">sqrt</span>(S/M_PI),m1,m2,t=<span class="number">50</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="comment">/*因为表面积是πr(r+l)那么r大概就是sqrt(表面积/π)*/</span></span><br><span class="line"><span class="keyword">while</span>(t--)&#123;<span class="comment">//控制迭代次数，50次</span></span><br><span class="line">m1=(l+l+r)/<span class="number">3</span>;</span><br><span class="line">m2=(l+r+r)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(f(m1)&lt;f(m2))l=m1;</span><br><span class="line"><span class="keyword">else</span> r=m2;</span><br><span class="line"><span class="comment">/*这部分基本一样*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;V&lt;&lt;<span class="built_in">endl</span>&lt;&lt;H&lt;&lt;<span class="built_in">endl</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//照题意输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你也可以三分$h$的值，只是通过$S$和$h$的值比较难求出$r$的值。</p><h2 id="3-本章小结"><a href="#3-本章小结" class="headerlink" title="$(3)$本章小结"></a>$(3)$本章小结</h2><p>其实一般的三分题，只需要：</p><ol><li>记住模板</li><li>选择要三分的数</li><li>修改<code>f(x)</code>函数</li><li>设置好左端点和右端点</li><li>调整精度</li></ol><p>就可以轻松$AC$。如果你想做更多三分题，<a href="https://blog.csdn.net/consciousman/article/details/53045734" target="_blank" rel="noopener">戳我</a>。</p><h1 id="4-结束"><a href="#4-结束" class="headerlink" title="$4.$结束"></a>$4.$结束</h1><p>蒟蒻第一次写文章，可能还不够熟练，如果文章有什么问题欢迎各位大佬指正，如果有什么漏掉的也欢迎各位大佬补充！</p><p>参考：</p><ul><li><a href="http://www.matrix67.com/blog/archives/1057" target="_blank" rel="noopener">漫话二分（下）| Matrix67: The Aha Moments</a></li><li><a href="http://ruanx.pw/post/%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE.html" target="_blank" rel="noopener">三分查找 - blue’s blog</a></li><li><a href="https://baike.baidu.com/item/%E5%8D%95%E5%B3%B0%E5%87%BD%E6%95%B0/7544838?fr=aladdin" target="_blank" rel="noopener">单峰函数_百度百科</a></li><li><a href="https://baike.baidu.com/item/0.618%E6%B3%95/7238973?fr=aladdin" target="_blank" rel="noopener">0.618法_百度百科</a></li><li><a href="https://baike.baidu.com/item/%E4%BC%98%E9%80%89%E6%B3%95/3111033?fr=aladdin" target="_blank" rel="noopener">优选法_百度百科</a></li><li><a href="https://baike.baidu.com/item/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95/449196?fr=aladdin" target="_blank" rel="noopener">秦九韶算法_百度百科</a></li><li><a href="https://baike.baidu.com/item/%E9%87%8D%E6%A0%B9/5030500?fr=aladdin" target="_blank" rel="noopener">重根（数学代数名词）_百度百科</a></li></ul><script type="math/tex; mode=display">\Huge The\ End.</script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黄金分割 </tag>
            
            <tag> 单峰函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭开虚数i的神秘面纱</title>
      <link href="/2019/%E6%8F%AD%E5%BC%80%E8%99%9A%E6%95%B0i%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/"/>
      <url>/2019/%E6%8F%AD%E5%BC%80%E8%99%9A%E6%95%B0i%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/</url>
      
        <content type="html"><![CDATA[<p>$By\ King$</p><blockquote><p>$e^{i\pi}+1=0$</p></blockquote><a id="more"></a><h1 id="1-i-是什么？"><a href="#1-i-是什么？" class="headerlink" title="$1.i$是什么？"></a>$1.i$是什么？</h1><p>如果按照<a href="https://baike.baidu.com/item/%E8%99%9A%E6%95%B0%E5%8D%95%E4%BD%8D/6803458?fr=aladdin#2" target="_blank" rel="noopener">数字定义</a>，$i^2=-1$，$i^3=-i$，$i^4=1$，$i^5=i$，$i^6=-1\dots$，你会发现$i$的幂每四个为一个循环，得出$i^{4n}=1$，$i^{4n+1}=i$，$i^{4n+2}=-1$，$i^{4n+3}=-i(n\in\mathbb{N})$</p><p>让我们引入一种全新的解释：它可以是一个旋转量。$i$是旋转$90^\circ$。</p><p>假如有一个实数数轴，在原点处又有一条数轴垂直于实数数轴，然后从$1$旋转$90^\circ$，就变成了$i$，再旋转$90^\circ$就变成了$-1$，因为乘法是充当着旋转的作用，而加减法是平移。</p><p>看下面的图你就知道了：</p><p><img src="https://s2.ax1x.com/2019/07/16/ZHMYNt.png" alt></p><p>这样是不是更好理解呢？</p><p>可能会有一些人不信$i$这种东西，就像在$18$世纪的欧洲数学家一样，他们不相信负数。</p><p>就像我们刚学会正数一样，只会加法，</p><p>后来懂了减法，但是$1-2=?$，于是我们就学会了负数，因此得知$1-2=-1$。</p><p>学了除法后，我们又懂得了什么是分数；学了$\pi$和根号后，又知道了什么是无理数。</p><p>任何事并不是有意义的，就像刚开始时人们认为$1-2$是无意义的，毕达哥拉斯认为$\sqrt{2}$是没有意义的一样。</p><blockquote><p>当我们发明某些东西时，我们的智力会有突飞猛进的进步。</p></blockquote><h1 id="2-e-i-pi-1-0"><a href="#2-e-i-pi-1-0" class="headerlink" title="$2.e^{i\pi}+1=0$"></a>$2.e^{i\pi}+1=0$</h1><p>这是十分著名的欧拉恒等式，它被称为最完美的公式，为什么呢？</p><blockquote><p>上帝创造的公式，我们只能看它而不能理解它。</p></blockquote><p>这个公式，涉及到了数学中几个著名的常数，将数学的各个分支结合到了一起。</p><ul><li>$e$，自然对数的底，它是个无理数，在高等数学、物理学中很常用，与增长息息相关，它等于$2.718281828459045\dots$，这有个好方法来记住前$15$位，是李永乐老师教的，首先是$2$个$1828$，然后是等腰直角三角形的三个内角的度数：$45$，$90$和$45$。计算$e$的公式有个比较简单的：$(1+\frac1{n})^n$，当$n$越大的时候，这个式子会越接近$e$，类似地，$e^x=(1+\frac{x}{n})^n$，顺带一提，$e^x$的导数是本身。</li><li>$\pi$，圆周率，也是个无理数，在几何中很常见，有$\pi$的地方就肯定有圆，相信大家小学就学过（这让我想起了小学背$2\pi=6.28$，$3\pi=9.42\dots$的恐惧，），它等于$3.1415926535897932\dots$，这里也有一个公式来计算它：$n\times\sin(\frac{180^\circ}{n})$，同样，当$n$越大的时候式子会越接近$\pi$，至于这个公式的推导，是类似于割圆法的思想，我会在以后的一篇博客上讲到。</li><li>$i$，虚数单位，这里就不多说了吧，刚刚讲完。</li><li>$1$，正整数的单位，$1$的$n$次方都等于$1(n\in\mathbb{R})$，而且任何数乘$1$都是本身。</li><li>$0$，最小的自然数，任何数加$0$都是本身。</li></ul><p>$The\ Mathematical\ Intelligencer$杂志举办过一次读者投票关于史上最美的公式，欧拉恒等式被当选。</p><p>这就是它为什么这么美的原因。</p><p>接下来，我们是得出这个公式的呢？</p><p><strong>请注意，接下来将会涉及到三角函数(弧度模式下)</strong></p><p>首先如果你了解泰勒公式，你肯定知道这三条式子</p><script type="math/tex; mode=display">e^x=\sum\limits_{i=0}^\infty(\frac{x^i}{i!})=\frac{x^0}{0!}+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}\dots</script><script type="math/tex; mode=display">\cos x=\sum\limits_{i=0}^\infty((-1)^i\frac{x^{2i}}{(2i)!})=\frac{x^0}{0!}-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^8}{8!}\dots</script><script type="math/tex; mode=display">\sin x=\sum\limits_{i=0}^\infty((-1)^i\frac{x^{2i+1}}{(2i+1)!})=\frac{x^1}{1!}-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\frac{x^9}{9!}\dots</script><p>由第一条式子代入$ix$，得出</p><script type="math/tex; mode=display">e^{ix}=\frac{i^0x^0}{0!}+\frac{i^1x^1}{1!}+\frac{i^2x^2}{2!}+\frac{i^3x^3}{3!}+\frac{i^4x^4}{4!}\dots</script><p>我们在开头说了$i$的幂是以四个为一循环的，于是</p><script type="math/tex; mode=display">e^{ix}=\frac{x^0}{0!}+\frac{ix^1}{1!}+\frac{-x^2}{2!}+\frac{-ix^3}{3!}+\frac{x^4}{4!}\dots</script><script type="math/tex; mode=display">e^{ix}=\frac{x^0}{0!}+\frac{ix^1}{1!}-\frac{x^2}{2!}-\frac{ix^3}{3!}+\frac{x^4}{4!}\dots</script><p>分一下组，将不带有$i$的分为一组，其他的分为一组并把$i$提取出来</p><script type="math/tex; mode=display">e^{ix}=(\frac{x^0}{0!}-\frac{x^2}{2!}+\frac{x^4}{4!}\dots)+(\frac{ix^1}{1!}-\frac{ix^3}{3!}+\frac{ix^5}{5!}\dots)</script><script type="math/tex; mode=display">e^{ix}=(\frac{x^0}{0!}-\frac{x^2}{2!}+\frac{x^4}{4!}\dots)+i(\frac{x^1}{1!}-\frac{x^3}{3!}+\frac{x^5}{5!}\dots)</script><p>然后就可以代入第二和第三条式子了，式子变得简单起来</p><script type="math/tex; mode=display">e^{ix}=\cos x+i\sin x</script><p>再代入$x=\pi$，因为说了是弧度模式，所以$\cos\pi=-1$，$\sin\pi=0$。所以式子最终变成了</p><script type="math/tex; mode=display">e^{i\pi}=-1+i\times0</script><script type="math/tex; mode=display">e^{i\pi}=-1</script><script type="math/tex; mode=display">\Large e^{i\pi}+1=0</script><p>但如果你不懂什么是泰勒公式，可以看下面这么一个几何证明：</p><p>你首先要知道<a href="https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/2568041?fr=aladdin#2_1" target="_blank" rel="noopener">复数的乘法</a>表现为幅角相加，模长相乘。</p><p>那么$(1+2i)(1+2i)=-3+4i$，但$(1+2i)(1+2i)$在图中应怎么表示呢？</p><p>答案是这样的：</p><p>先在$0$，$1$，和$1+2i$这三个点构造三角形。</p><p><img src="https://s2.ax1x.com/2019/07/16/ZbWZRI.png" alt></p><p>然后复制这个三角形并旋转使他们贴合在一起。</p><p><img src="https://s2.ax1x.com/2019/07/16/ZbWnQP.png" alt></p><p>然后再把旋转后的三角形照比例缩放，使直角和上面的锐角在同一个点上。</p><p><img src="https://s2.ax1x.com/2019/07/19/ZvlErt.png" alt></p><p>最后旋转后的三角形的上面的锐角的顶点坐标就是$(1+2i)^2$也就是$-3+4i$了。</p><p>类似的，像上面的方法可以求出$(a+bi)^2$的值。回顾一遍：</p><ol><li>先在$0$，$1$，和$a+bi$这三个点构造三角形。</li><li>然后复制这个三角形并旋转使他们贴合在一起。</li><li>然后再把旋转后的三角形照比例缩放，使直角和上面的锐角在同一个点上。</li><li>最后旋转后的三角形的上面的锐角的顶点坐标就是$(a+bi)^2$了。</li></ol><p>用类似的方法我们可以求出$(a+bi)^n$，只需要在旋转后的三角形上再操作几次就行了。</p><p>还记得吗，在前面提到过一个公式，$e^x=(1+\frac{x}{n})^n$，当$n$越大的时候就会越精确。</p><p>那么如果我代入$x=i\pi$呢？</p><p>那么原式变成了$e^{i\pi}=(1+i\frac{\pi}{n})^n$，这有点像我们刚学的$(a+bi)^n$啊！没错，让我们来试一下，如果不出意外，最后的点会接近于$-1$，下面是$n=3$的情况：</p><p><img src="https://s2.ax1x.com/2019/07/19/ZvlVqP.png" alt></p><p>好像还离$-1$远得多呢！让我们试一试$n=10$吧。</p><p><img src="https://s2.ax1x.com/2019/07/16/ZqpPIJ.png" alt></p><p>嗯…接近了很多，但还是有点远，现在我们直接让$n=100$，看一下有多接近吧！</p><p><img src="https://s2.ax1x.com/2019/07/16/ZqpCa4.png" alt></p><p>不错，但是如果要让它更接近，这时应该将$n=\infty$，此时$e^{i\pi}=-1$，也就是说$e^{i\pi}+1=0$。</p><p>你也会发现，圆从$1$到$-1$的弧的长度正好是$\pi$！</p><p>综上所述，我们可以得到简短的证明：</p><blockquote><p>在平面内，从$1$开始，垂直增长$\pi$个单位变成$-1$，再加$1$变成$0$</p></blockquote><p><img src="https://s2.ax1x.com/2019/07/17/ZqqONq.png" alt></p><h1 id="3-关于-i-的实数"><a href="#3-关于-i-的实数" class="headerlink" title="$3.$关于$i$的实数"></a>$3.$关于$i$的实数</h1><h2 id="1-i-i"><a href="#1-i-i" class="headerlink" title="$1.i^i$"></a>$1.i^i$</h2><p>相信我，当你看到$i^i$的时候，你一定会以为是一个虚数，但是<strong>你错了</strong>，它是一个实数！</p><p>那么如何求出它呢？当然是用</p><script type="math/tex; mode=display">\Huge\text{欧拉恒等式}</script><p>当然要活学活用啊</p><p>首先我们知道$e^{i\pi}+1=0$，也就是说$e^{i\pi}=-1$，两边同时开方（相当于$\frac{1}{2}$次方）得到$e^{\frac{i\pi}{2}}=i$</p><p>继续两边同时$i$次方，我们就构造出了$i^i$，那么等式变成了$e^{\frac{i\pi}{2}i}=i^i$，右边变成$e^{\frac{i^2\pi}{2}}$，也就是$e^{-\frac{\pi}{2}}$，然而它是个实数，约等于$0.207879576350762$。</p><p>类似这样，可以得出$i^x=e^{\frac{i\pi x}{2}}$，再进行变换得出以$i$为底的对数函数$\log_i x=\frac{2\ln x}{i\pi}$</p><h2 id="2-cos-i"><a href="#2-cos-i" class="headerlink" title="$2.\cos i$"></a>$2.\cos i$</h2><p>就拿这两个泰勒公式来讲吧。</p><script type="math/tex; mode=display">e^x=\frac{x^0}{0!}+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}\dots</script><script type="math/tex; mode=display">\cos x=\frac{x^0}{0!}-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^8}{8!}\dots</script><p>第二条式子代入$x=i$，得出：</p><script type="math/tex; mode=display">\cos i=\frac{i^0}{0!}-\frac{i^2}{2!}+\frac{i^4}{4!}-\frac{i^6}{6!}+\frac{i^8}{8!}\dots</script><p>这说明了$\cos i$一定是实数，为什么呢？</p><p>因为式子中$i$的幂都是偶数，而开头有写$i^{4n}=1$，$i^{4n+2}=-1$，而偶数不是$4n$就是$4n+2$了，而这样的幂都是实数，由于实数的封闭性，所以$\cos i$一定是实数。</p><p>让我们继续，化简一下：</p><script type="math/tex; mode=display">\cos i=\frac{1}{0!}+\frac{1}{2!}+\frac{1}{4!}+\frac{1}{6!}+\frac{1}{8!}\dots</script><p>这有一点像$e$的泰勒公式啊，我们列一下$e$的泰勒展开：</p><script type="math/tex; mode=display">\cos i=\frac{1}{0!}+\frac{1}{2!}+\frac{1}{4!}+\frac{1}{6!}+\frac{1}{8!}\dots</script><script type="math/tex; mode=display">e=\frac{1}{0!}+\frac{1}{1!}+\frac{1}{2!}+\frac{1}{3!}+\frac{1}{4!}\dots</script><p>这时我们想到应该把$\frac{1}{1!}$、$\frac{1}{3!}$这一类的东西去掉，再看一眼$e^x$的泰勒公式，就会恍然大悟：</p><script type="math/tex; mode=display">e^x=\frac{x^0}{0!}+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}\dots</script><p>只需要代入$x=-1$，两条式子相加再除以二就可以了！</p><script type="math/tex; mode=display">e^{-1}=\frac{1}{0!}-\frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+\frac{1}{4!}\dots</script><p>相加得</p><script type="math/tex; mode=display">e+e^{-1}=(\frac{1}{0!}+\frac{1}{2!}+\frac{1}{4!}\dots)+(\frac{1}{0!}+\frac{1}{2!}+\frac{1}{4!}\dots)</script><p>再除以二得到</p><script type="math/tex; mode=display">\frac{e+e^{-1}}{2}=\frac{1}{0!}+\frac{1}{2!}+\frac{1}{4!}\dots</script><p>也就是$\cos i$的值了。这十分惊讶，$\cos i$居然是$e$和其倒数的平均值！大约等于$1.543080634815244$。</p><h1 id="4-什么数的相反数与倒数相等？"><a href="#4-什么数的相反数与倒数相等？" class="headerlink" title="$4.$什么数的相反数与倒数相等？"></a>$4.$什么数的相反数与倒数相等？</h1><p>一天看奥数书，有一个问题：</p><blockquote><p>你能找到两个<strong>有理数</strong>，他们互为相反数，又互为倒数吗？</p></blockquote><p>当然这种题是很简单的，因为这两个数互为相反数，所以可以设为$x$和$-x$，又要满足互为倒数，那么这两个数的乘积应等于$1$，所以得出方程$x\times(-x)=1$，显然满足这个方程的有理数解是不存在的。</p><p>那么什么数的相反数与倒数相等呢？</p><p>根据本文的知识很容易就能得出$x=\sqrt{-1}$，也就是$i$。</p><p>当然也有另一种方法：</p><script type="math/tex; mode=display">1=1</script><script type="math/tex; mode=display">-i^2=1</script><script type="math/tex; mode=display">-i=\frac{1}{i}</script><h1 id="5-i-的幂"><a href="#5-i-的幂" class="headerlink" title="$5.i$的幂"></a>$5.i$的幂</h1><p>前面说过了，$i^{4n}=1$，$i^{4n+1}=i$，$i^{4n+2}=-1$，$i^{4n+3}=-i(n\in\mathbb{N})$，但是我们不能把思想禁锢在自然数中，我们得扩展直到复数。</p><h2 id="1-负整数"><a href="#1-负整数" class="headerlink" title="$1.$负整数"></a>$1.$负整数</h2><p>我们来试几个数：$i^{-1}=\frac{1}{i}$，刚刚证明了$i$的倒数和相反数相等，那么$i^{-1}=-i$。</p><p>$i^{-2}=\frac{1}{i^2}=\frac{1}{-1}=-1$</p><p>$i^{-3}=\frac{1}{i^3}=\frac{1}{-i}=-(-i)=i$</p><p>$i^{-4}=\frac{1}{i^4}=\frac{1}{1}=1$</p><p>$i^{-5}=\frac{1}{i^5}=\frac{1}{i}=-i$</p><p>在这里又出现了周期，也是$-i,-1,i,1$的循环，而且你会发现他们也符合$i^{4n}=1$，$i^{4n+1}=i$，$i^{4n+2}=-1$，$i^{4n+3}=-i$的规则！（只是这里$n$是负数而已）。</p><p>现在我们已经把整数搞定了，下一站，分数。</p><h2 id="2-分数"><a href="#2-分数" class="headerlink" title="$2.$分数"></a>$2.$分数</h2><p>这里的分数</p><h3 id="1-分子为-1-的分数"><a href="#1-分子为-1-的分数" class="headerlink" title="$1.$分子为$1$的分数"></a>$1.$分子为$1$的分数</h3><p>我们知道$i^{\frac{1}{x}}=\sqrt[x]{i}$</p><p>那么怎么求出$\sqrt[1]{i}$、$\sqrt[2]{i}$、$\sqrt[3]{i}$、$\sqrt[4]{i}$$呢？</p><p>为什么只用求到$4$次方？</p><p>可以分类讨论，$p$次方根的$p$必定可以表示成$4n$、$4n+1$、$4n+2$、$4n+3$其中的一种。</p><ul><li>$p=4n+1$，那么$i^1=i^p=i^{4n+1}$，两边同时开$4n+1$次方，那么$\sqrt[4n+1]{i}=\sqrt[1]{i}$。</li><li>$p=4n+2$，那么$i^2=i^p=i^{4n+2}$，两边同时开$(4n+2)2$次方，那么$\sqrt[4n+2]{i}=\sqrt[2]{i}$。</li><li>$p=4n+3$，那么$i^3=i^p=i^{4n+3}$，两边同时开$(4n+3)3$次方，那么$\sqrt[4n+3]{i}=\sqrt[3]{i}$。</li><li>$p=4n$，那么$i^0=i^p=i^{4n}$，两边同时开$4n$次方，那么$\sqrt[4n]{i}=\sqrt[1]{i}$。</li></ul><p>证明完了，我们要开始求值了。</p><p>很容易得出$\sqrt[1]{i}$等于$i$。</p><p>接下来介绍一种方法：</p><ol><li>因为$\sqrt[2]{i}$一定可以表述成$a+bi$的形式，那么假设$\sqrt[2]{i}=a+bi$</li><li>两边同时平方，得出$i=(a+bi)^2=a^2+2abi-b^2$.</li><li>左边与右边的实数虚数部分一一对应：$0+1i=(a^2-b^2)+2abi$，那么$a^2-b^2=0$，$2ab=1$。</li><li>解出这个方程组，得出$a=b=\sqrt{\frac{1}{2}}$或$-\sqrt{\frac{1}{2}}$，那么，$\sqrt[2]{i}=\pm\frac{1+i}{\sqrt{2}}$</li></ol><p>类似这样，我们可以求出$\sqrt[3]{i}$和$\sqrt[4]{i}$的值了！</p><p>这里给出$\sqrt[3]{i}$的解：$\sqrt[3]{i}=-i=\frac{i\pm\sqrt{3}}{2}$</p><h3 id="2-分子不为-1-的分数"><a href="#2-分子不为-1-的分数" class="headerlink" title="$2.$分子不为$1$的分数"></a>$2.$分子不为$1$的分数</h3><p>其实这很简单，因为$i^{\frac{a}{b}}={(i^{\frac{1}{b}})}^a$，而且我们知道$i^{\frac{1}{b}}$的值，那么代入再$a$次方即可。</p><p>至此，我们将有理数完成了。</p><h2 id="3-无理数"><a href="#3-无理数" class="headerlink" title="$3.$无理数"></a>$3.$无理数</h2><p><del>目前我还没有想到这一类的解决方法，如果你们可以，请在下方评论区告诉我，谢谢。</del></p><p><code>Update 2019.8.25</code></p><p>今天突然想到一个计算无理数幂的方法——不断逼近</p><script type="math/tex; mode=display">\Huge a^b=\prod\limits_{x=-\lfloor\log_{10}b\rfloor}^{\infty}(a^{\frac{\lfloor n\times10^x\rfloor\mod10}{10^x}})</script><p>假设我们要算$2^\pi$，那么可以把$\pi$分成$3,0.1,0.04,0.001,0.0005,0.00009\dots$这些，然后因为$n^{a+b}=n^a\times n^b(a,b=\frac{m}{n})$，所以$2^\pi=2^3\times2^{0.1}\times2^{0.04}\times2^{0.001}\times\dots$，当计算的项数越多，答案就越精确。</p><p>那么</p><script type="math/tex; mode=display">\Huge i^n=\prod\limits_{x=-\lfloor\log_{10}n\rfloor}^{\infty}(i^{\frac{\lfloor n\times10^x\rfloor\mod10}{10^x}})</script><p>因为我们可以计算$i^t(t=\frac{m}{n})$，而$\lfloor n\times10^x\rfloor\mod10$一定是一个有理数，那么我们计算出有理数幂后，相乘即可。</p><h2 id="4-复数"><a href="#4-复数" class="headerlink" title="$4.$复数"></a>$4.$复数</h2><p>假使我们将实数搞定了（也就是无理数可以解决了），那么就到了虚数，但是虚数已经知道了$i^i=e^{-\frac{\pi}{2}}$。</p><p>那么，我们将开始最后一站——复数。</p><p>复数是类似于$a+bi$的数，之前有提及过。</p><p>那么$i^{a+bi}=i^a\times i^{bi}$，左边的$i^a$我们已经可以求了，右边我们可以再变换：$i^{bi}={(i^i)}^b=(e^{-\frac{\pi}{2}})^b$。</p><p>综合起来，$i^{a+bi}=i^a\times e^{-\frac{\pi b}{2}}$</p><p>现在，我们就可以求出$i$的任何次幂了。</p><h2 id="5-i-x-1-？？？"><a href="#5-i-x-1-？？？" class="headerlink" title="$5.i^{x}=1$？？？"></a>$5.i^{x}=1$？？？</h2><p>我发现一个结论，就是$i$的任何次方都是$1$。</p><p>这个结论也许是错的，我不能推翻它。</p><p>从下面的式子可以看出：</p><script type="math/tex; mode=display">i^x=i^{4\times\frac{x}{4}}={(i^4)}^{\frac{x}{4}}=1^{\frac{x}{4}}=1</script><p>如果你们能推翻它，请在下方评论区告诉我，谢谢。</p><h1 id="6-Bug"><a href="#6-Bug" class="headerlink" title="$6.Bug$"></a>$6.Bug$</h1><p>作为文章的最后，给大家再看一个悖论：</p><script type="math/tex; mode=display">\frac{-1}{1}=\frac{1}{-1}</script><script type="math/tex; mode=display">\sqrt{\frac{-1}{1}}=\sqrt{\frac{1}{-1}}</script><script type="math/tex; mode=display">\frac{\sqrt{-1}}{\sqrt{1}}=\frac{\sqrt{1}}{\sqrt{-1}}</script><script type="math/tex; mode=display">\frac{i}{1}=\frac{1}{i}</script><script type="math/tex; mode=display">1=i^2</script><script type="math/tex; mode=display">1=-1</script><p>当然这肯定是有很大的$bug$的，这就让你们自己去探索吧。</p><p>$\color{white}{提示：开方有两种结果}$</p><hr><script type="math/tex; mode=display">\Huge The\ End.</script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么B站用户看抖音用户不顺眼</title>
      <link href="/2019/%E4%B8%BA%E4%BB%80%E4%B9%88B%E7%AB%99%E7%94%A8%E6%88%B7%E7%9C%8B%E6%8A%96%E9%9F%B3%E7%94%A8%E6%88%B7%E4%B8%8D%E9%A1%BA%E7%9C%BC/"/>
      <url>/2019/%E4%B8%BA%E4%BB%80%E4%B9%88B%E7%AB%99%E7%94%A8%E6%88%B7%E7%9C%8B%E6%8A%96%E9%9F%B3%E7%94%A8%E6%88%B7%E4%B8%8D%E9%A1%BA%E7%9C%BC/</url>
      
        <content type="html"><![CDATA[<p>$By\ RioBlu$</p><p>新兴的短视频软件迭出不穷，但大多$B$站用户却一直对这类软件持否定的态度</p><p>这是为什么呢？</p><a id="more"></a><h2 id="首先先介绍一下Bilibili"><a href="#首先先介绍一下Bilibili" class="headerlink" title="首先先介绍一下Bilibili"></a>首先先介绍一下Bilibili</h2><p>哔哩哔哩$(bilibili)$现为国内领先的年轻人文化社区，是一个知名的视频弹幕网站，它的特色不用说，就是弹幕（让我想起了之前某视频卡死电脑的经历）</p><p>人称B站，与A站$(AcFun)$，N站$(NicoNico)$在二次元视频弹幕网站可谓是三霸</p><h3 id="B站的优势在哪呢？"><a href="#B站的优势在哪呢？" class="headerlink" title="B站的优势在哪呢？"></a>B站的优势在哪呢？</h3><ul><li><p>有很多不同视频分区的大佬（放假君、中国$boy$、山下智博、$papi$酱、敖厂长、欣小萌、$ilem$，李永乐等大佬）</p></li><li><p>底蕴足，相比$C$站$O$站$D$站这种网站可谓是早了数年（$2009$年建立）</p></li><li><p>有很多播放上千万的番剧/国创，镇站之宝(比如 我的烤面筋融化你的心，我单集循环了$10$次)</p></li><li><p>舞蹈区的大佬，女装，二次元化，$cosplay$，番剧。自然会吸引很多宅男宅女和很多年轻人</p></li></ul><hr><h2 id="后面我们来介绍短视频软件中比较火的抖音"><a href="#后面我们来介绍短视频软件中比较火的抖音" class="headerlink" title="后面我们来介绍短视频软件中比较火的抖音"></a>后面我们来介绍短视频软件中比较火的抖音</h2><p>抖音，是一个拍短视频的音乐创意视频社交软件，而且是一个专注年轻人音乐短视频社区平台，在我天天听我妹看抖音的熏陶下，在我的心目中，抖音的特色是：音乐，搞笑，吃鸡的一些对话（或许搞笑，或许感动，或许有关小哥哥救小姐姐）</p><p>与其类似的还有快手，微视，火山小视频（人称：南抖音，北快手，智障界两泰斗）</p><h3 id="抖音的优势在哪呢？"><a href="#抖音的优势在哪呢？" class="headerlink" title="抖音的优势在哪呢？"></a>抖音的优势在哪呢？</h3><ul><li><p>大规模宣传，在许许多多的综艺视频中宣传，甚至在2019年春晚都有它的身影</p></li><li><p>内容搞笑，内容丰富多样</p></li><li><p>音乐，大多数很火的音乐都从这儿开始火</p></li><li><p>方便，随时都可以刷</p></li></ul><hr><h2 id="那B站的用户为什么看抖音不顺眼"><a href="#那B站的用户为什么看抖音不顺眼" class="headerlink" title="那B站的用户为什么看抖音不顺眼"></a>那B站的用户为什么看抖音不顺眼</h2><p>我是一个$B$站人士，所以为什么$B$站的人对抖音不顺眼是深有感触的</p><ul><li><p>刻板印象，对于那些在裤裆里放鞭炮早有耳闻，同时在$2019$年$4$月，$B$站后台泄露，部分账号可以在快视频登录这些都影响了B站用户对短视频软件的看法</p></li><li><p>内容表现方式不同，抖音是短视频平台，而B站是长视频平台，短视频没有像B站有鬼畜区，游戏区，科普区。相对来说可以在$B$站学到的知识比较系统化，有真正的老师来直播授课。</p></li><li><p>认为那些东西低俗，营销，对于那些小孩子不大好（印尼已经禁止了抖音在海外版的$Hik Tok$）</p></li><li><p>抖音用户可以在几十分钟内很方便的造好一个视频，而$B$站$up$主需要几天甚至几月才能做完一个视频</p></li><li><p>出现负面事件，比如：（邱少云，被$**$ 这种侮辱烈士的内容）</p></li><li><p>一些抖音搬运视频，百万播放量并不少见，可B站的原创$up$主可只有几万的播放量时，很难对抖音产生认同</p></li><li><p>版权问题比较严重，盗用一些作者明确有声明的视频音频</p></li></ul><p>在这里举几个例子：</p><ul><li><p>莉哥被封杀：她篡改了国歌歌词，并且还在直播时演唱了改编版本。莉哥后来因公然侮辱国歌被行政拘留，再后来她也就被封杀了。</p></li><li><p>网上有一个比较火的模仿叫“我们一起学猫叫”，很多人都在模仿拍摄，给网友们带来了新鲜和搞笑。但是其中却有一个小姑娘就拍自己模仿视频的时候不小心拍下了不雅事件并传播了出去。视频里面记录了小姑娘巧合之下拍到的妈妈洗澡的视频，就是这么巧，那个时候浴室的门没有关闭严实。就是这段视频，小姑娘上传到网络，抖音居然上“推荐”是什么意思？这不仅仅是暴露了小姑娘的家庭隐私，引起矛盾纠纷，而且充满了巨大的负能量和消极的不良影响。</p></li></ul><hr><h2 id="作为一个B站用户对抖音的建议"><a href="#作为一个B站用户对抖音的建议" class="headerlink" title="作为一个B站用户对抖音的建议"></a>作为一个B站用户对抖音的建议</h2><ul><li><p>审核水平有待提高，降低不良事故的发生可能性，这样可以提高抖音在$B$站用户在心中的地位</p></li><li><p>提高用户道德修养，现在抖音也有一些公益广告加入了，亦更新了与时俱进的健康系统</p></li><li><p>注重版权问题，拒绝盗版，尊重原作者的劳动成果</p></li><li><p>提高视频质量，加强直播监控</p></li></ul><hr><p>说了这么多，也希望抖音可以改进到一个良好状态，现在也有不少$B$站$up$主去抖音改善环境，其中我认识的以籽岷较为有名，他也鼓励一些朋友一起去改善那里</p><p>最后衷心的祝愿抖音和$B$站发展的越来越好，$Bye$</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bilibili </tag>
            
            <tag> 抖音 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,World!</title>
      <link href="/2019/Hello-World/"/>
      <url>/2019/Hello-World/</url>
      
        <content type="html"><![CDATA[<p><img src="\images\avatar.jpg" alt></p><script type="math/tex; mode=display">\Huge2019.7.11</script><p><strong>在浏览本站前，请先务必阅读此篇文章。</strong></p><a id="more"></a><hr><h1 id="1-关于我们"><a href="#1-关于我们" class="headerlink" title="$1.$关于我们"></a>$1.$关于我们</h1><h2 id="1-博客概况"><a href="#1-博客概况" class="headerlink" title="$(1)$博客概况"></a>$(1)$博客概况</h2><p>这个博客由两人共同创建，主要涉及数学、计算机科学、学习笔记等方面。</p><p>一个是我$King$，还有是$RioBlu$，这也是名称$R\&amp;K$的由来。</p><ul><li>共同爱好：扫雷 $2048$ $bilibili$ 电音 代码</li><li>出产地：中国广东</li></ul><p>如果不出意外，博客每周会更$2$篇。即使会少也会赶回来。</p><p>一般在$RioBlu$的文章上会有$By\ RioBlu$，我的文章上会有$By\ King$。</p><p>如果都没有，那要么是共同创作，或者是公告（就例如本文）。</p><h2 id="2-博客网站上的-2005czq-是什么？为什么是-2019-7-11-？"><a href="#2-博客网站上的-2005czq-是什么？为什么是-2019-7-11-？" class="headerlink" title="$(2)$博客网站上的$2005czq$是什么？为什么是$2019.7.11$？"></a>$(2)$博客网站上的$2005czq$是什么？为什么是$2019.7.11$？</h2><p>$2005$是我们的出生日期，而$czq$是$King$的名字。</p><p>而在$2019$，我们$13$岁上初一，也就是$7$年级，而且正好$7.11$是刚考完试的第一天。</p><h2 id="3-如何联系我们"><a href="#3-如何联系我们" class="headerlink" title="$(3)$如何联系我们"></a>$(3)$如何联系我们</h2><blockquote><p>$QQ$联系：<br>$RioBlu$的$QQ:$<a href="https://wpa.qq.com/msgrd?v=3&amp;uin=1270585465" target="_blank" rel="noopener">1270585465</a><br>$King$的$QQ:$<a href="https://wpa.qq.com/msgrd?v=3&amp;uin=3376299315" target="_blank" rel="noopener">3376299315</a></p></blockquote><hr><blockquote><p>洛谷博客：<br>$King$的洛谷博客：<a href="https://3-3-7-6-2-9-9-3-1-5.blog.luogu.org/" target="_blank" rel="noopener">戳我</a><br>$RioBlu$的洛谷博客：<a href="https://www.luogu.org/blog/RioBlu1270585465/" target="_blank" rel="noopener">戳我</a></p></blockquote><hr><blockquote><p>$QQ$邮箱：<br>$RioBlu$的$Email$: <a href="mailto:1270585465@qq.com" target="_blank" rel="noopener">1270585465@qq.com</a><br>$King$的$Email$：<a href="mailto:3376299315@qq.com" target="_blank" rel="noopener">3376299315@qq.com</a></p></blockquote><p>可以<a href="https://github.com/2005czq" target="_blank" rel="noopener">$Github$</a>联系，但是不常上$Github$。</p><h1 id="2-投喂"><a href="#2-投喂" class="headerlink" title="$2.$投喂"></a>$2.$投喂</h1><p>如果您觉得小站对您有帮助，可以通过投喂来支持我们，您的支持将鼓励我们继续创作！</p><p>当然，如果您感谢我们但不能投喂，也可以向他人宣传我们的博客。十分感谢。</p><p>如果您一次投喂$\ge5$软妹币，会进入到致谢名单，我们对您以诚挚的感谢。</p><p>我们将使用这些资金购买和续费域名。</p><h1 id="3-友链"><a href="#3-友链" class="headerlink" title="$3.$友链"></a>$3.$友链</h1><p>如果您的博客更好，或希望在此推广您的博客，我们可以互加友链，可以通过上面的方式联系我，也可以在下方评论我。（暂不支持头像）</p><p>博客要求：</p><ol><li>没有广告推广</li><li>会持续更新，不会咕很久</li><li>可以稳定访问</li></ol><p>我的友链：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名称：R&amp;K</span><br><span class="line">头像：https://i.loli.net/2019/07/14/5d2a0de3d8f9725674.jpg</span><br><span class="line">网站：https://2005czq.github.io/</span><br><span class="line">说明：Doing is better than Saying.</span><br></pre></td></tr></table></figure></p><hr><p>友链：</p><ol><li><a href="https://2005czq.github.io">R&amp;K</a>的博客</li></ol><hr><p>温馨提示：</p><ol><li>在浏览本站时，因评论系统不支持$Markdown$和$\LaTeX$，所以可以将$Markdown$代码发送，若代码过长，可使用<a href="https://paste.ubuntu.com/" target="_blank" rel="noopener">这个网站</a>将代码存入，再发送网址。</li><li>如果您发现我们的文章有误，可以联系我们，也可以在文章下面的评论区指正，感谢！</li><li>本博客所有文章 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
