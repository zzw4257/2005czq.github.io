<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ȥ�⣺����������P��ʹ��2��N�����ֶ���������P</title>
      <link href="/2019/%E8%B6%A3%E9%A2%98%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%AD%A3%E6%95%B4%E6%95%B0P%EF%BC%8C%E4%BD%BF%E5%BE%972%E5%88%B0N%E7%9A%84%E6%95%B0%E5%AD%97%E9%83%BD%E6%95%B4%E9%99%A4%E4%B8%8D%E4%BA%86P/"/>
      <url>/2019/%E8%B6%A3%E9%A2%98%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%AD%A3%E6%95%B4%E6%95%B0P%EF%BC%8C%E4%BD%BF%E5%BE%972%E5%88%B0N%E7%9A%84%E6%95%B0%E5%AD%97%E9%83%BD%E6%95%B4%E9%99%A4%E4%B8%8D%E4%BA%86P/</url>
      
        <content type="html"><![CDATA[<p>$By\ RioBlu$</p><p>�ɲ����Զ���������$P$��ʹ��$2$��$N$�����ֶ���������$P$?</p><a id="more"></a><p>��ʵ�����кܶ࣬���Ƚ�һ���ǳ����򵥵�</p><h2 id="P-N-1"><a href="#P-N-1" class="headerlink" title="$P=N!+1$"></a>$P=N!+1$</h2><p>P��$2$��$n$����������һ��̫����!</p><p>��϶�ʮ�־���</p><p>������������Ļ�������</p><p>�ٿ���һ���ȽϾ����</p><h2 id="P-��-N-������һ������"><a href="#P-��-N-������һ������" class="headerlink" title="$P=$��$N$������һ������"></a>$P=$��$N$������һ������</h2><p>һ����$N$�����������ô���ܻ�����$2$��$N$��������</p><p>��ȷ��Ҳ�ǳ���������ֶ������ͬһ��$N$�³��ֶ���𰸣����˵ÿһ��$N$ֻ��һ���𰸣���Ӧ�øĳ�<strong>$P$=��$N$������С������</strong></p><p>��Ҳ�в����˻����ʮ�ָ���</p><p>������λͯЬ</p><h2 id="P-����С�ڵ���-N-�������L�-1"><a href="#P-����С�ڵ���-N-�������L�-1" class="headerlink" title="P=����С�ڵ���$N$�������Ļ�$+1$"></a>P=����С�ڵ���$N$�������Ļ�$+1$</h2><p>��ô$P��$2$��$N$�е�������������һ������������</p><p>�ǣ���Щ�����أ�</p><p>����Ҳ�ܺý��ͣ���˵һ������������$2$�ˣ�����������$6$��</p><p>����$N=7$</p><p>$P=2\times3\times5\times7+1=211$</p><p>��˵$P\mod2$������$0$��$P\mod3$������$0$</p><p>��ô$6=2\times3$����ô����$P\mod6=0$�أ�</p><p>Ŷ!�������˼���е��Ѷ�����û��֮ǰ����ô��</p><p>ȷʵ���������ǵ�һ�ֵ������棬�ȵ�һ����˵��С����һЩ��������Щ��̵���˵��Сһ�����Ǻ��£���������Բ������ĸ߾��ȳ˷���</p><p>���������˵˵��ͷϷ</p><h2 id="P-1"><a href="#P-1" class="headerlink" title="$P=1$"></a>$P=1$</h2><p>�Һ��ҵ�С����Ƕ�������!</p><p>���������ӵķ�����������ϸ��ζһ�£�ȷʵ�����ǶԵ�</p><p>����˼������ô�ã���һ��$P=1$����ˣ�������</p><p>���ԣ�����һЩ���ǿ���Ͷ��ȡ�ɵģ�����С�ģ���������������Ŷ</p>]]></content>
      
      
      <categories>
          
          <category> ��ѧ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ���� </tag>
            
            <tag> ��ѧ </tag>
            
            <tag> Ȥ�� </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>��η�ֹ��Ϸ�浵���۸�</title>
      <link href="/2019/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E8%A2%AB%E7%AF%A1%E6%94%B9/"/>
      <url>/2019/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E8%A2%AB%E7%AF%A1%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<p>$By\ King$</p><p>����ڸ���������Ϸ��������һ���浵�Ĺ��ܡ�������Ϸ�浵�����ױ��۸ģ����������ǽ�һ����η�ֹ��Ϸ�浵���۸ġ�</p><a id="more"></a><h1 id="1-�l�λ��"><a href="#1-�l�λ��" class="headerlink" title="1.�ļ�λ��"></a>1.�ļ�λ��</h1><p>�ܶ൥����Ϸ����ֱ�Ӱ���Ϸ�浵��������Ϸ��ͬ�ļ����У�֮ǰ$RioBlu$����<code>ͳһ����</code>����������<del>������۸��߿���һ��</del>��</p><p>�������ǿ��Խ��ļ�������$C$�̰���$D$����Щ�ġ�</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">O</span><span class="params">(<span class="string">"C:\\2005czq.github.io"</span>)</span></span>;</span><br><span class="line">O&lt;&lt;a;</span><br></pre></td></tr></table></figure><p>�������������һЩȱ�ݣ���Щ������û��$D$����Щ�ģ���������û�ǿ��ɾ����ʱ������������������浵�����ĸ�λ�ã�ֱ�Ӱ���<code>exe</code>�ļ�ɾ�ˡ������ͻ��в�����</p><h1 id="2-�����l�"><a href="#2-�����l�" class="headerlink" title="2.�����ļ�"></a>2.�����ļ�</h1><p>���ǿ��������ļ�ʹ�۸����Ҳ����ļ���</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetFileAttributes(<span class="string">"2005czq.github.io"</span>,FILE_ATTRIBUTE_HIDDEN);<span class="comment">//����</span></span><br><span class="line">SetFileAttributes(<span class="string">"2005czq.github.io"</span>,FILE_ATTRIBUTE_NORMAL);<span class="comment">//ȡ������</span></span><br></pre></td></tr></table></figure><p>���������ļ���Ҳ�����á�</p><p>ȱ�ݣ����Կ���ͨ��<code>����-�ļ���ѡ��-�鿴-�߼�����</code>����ʾ���б����ص��ļ���</p><p><strong>ע�⣺���ļ�������ʱ�������ǿ��Զ��ļ�����<code>DeleteFile</code>��<code>ifstream</code>�����������Ҫִ��<code>ofstream</code>��������Ҫ�Ƚ��ļ�ɾ��</strong></p><h1 id="3-����"><a href="#3-����" class="headerlink" title="3.����"></a>3.����</h1><p>��õķ����϶��Ǽ����ˡ�</p><h2 id="1-���Լ����o�"><a href="#1-���Լ����o�" class="headerlink" title="(1)���Լ����õ�"></a>(1)���Լ����õ�</h2><ul><li>��<code>�й����� ����ս��</code>���棺<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r=rand(),r2=rand();<span class="comment">//�������������</span></span><br><span class="line">r2+=r;</span><br><span class="line">O&lt;&lt;r*r*r&lt;&lt;<span class="string">" "</span>&lt;&lt;r2*r2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)O&lt;&lt;table[i][j]*table[i][j]+r2&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">O&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L_len;i++)</span><br><span class="line">O&lt;&lt;Line[i].x1-r&lt;&lt;<span class="string">" "</span>&lt;&lt;Line[i].y1+r&lt;&lt;<span class="string">" "</span>&lt;&lt;Line[i].x2-r2&lt;&lt;<span class="string">" "</span>&lt;&lt;Line[i].y2+r2&lt;&lt;<span class="string">" "</span>&lt;&lt;Line[i].eat*<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><p>��Ϊ��ʱ��Ϸ���Ǻܳ���<del>����������Ҳ�ǣ�</del>�����Լ����㷨�õĲ����ر�á�</p><ul><li><code>������</code>����ģ����ﲻ���������ˣ�������������һ������Ȼ���������һ�������������浵��Ȼ���Ժ�����ݶ���ͨ�������Կ�ó������ң��浵���ȥ����һ��ͼƬ��</li></ul><h2 id="2-���������㷨"><a href="#2-���������㷨" class="headerlink" title="(2)���������㷨"></a>(2)���������㷨</h2><p>ֻҪ�����뵽�Ķ����ԣ�����$MD5$��$SHA256$����Щ�㷨��ȫ�Ⱥܸߣ������ֻ�Ǳ��С��Ϸ�������Լ���Ƽ����㷨��</p><h2 id="3-��ν��浵���ͼT"><a href="#3-��ν��浵���ͼT" class="headerlink" title="(3)��ν��浵���ͼƬ"></a>(3)��ν��浵���ͼƬ</h2><p>��ʵ���ʮ�ּ򵥣��ٶ�Ҳ�ǿ����ҵ��ġ�</p><p>���ǽ����ݴ�Ϊ<code>ppm</code>�ļ���һ��<code>Linux</code>��ͼƬ��ʽ���������ļ��Ĵ洢��ʽʮ�ּ򵥣�</p><blockquote><p>P3 ͼƬ�� ͼƬ�� 255<br>������ ͼƬ��*ͼƬ�� �����ص�<br>ÿ�����ص�RGBֵ����ֵ��R G B��ÿ��ֵ��0��255֮�䣩</p></blockquote><p>�����������һ����</p><blockquote><p>P3 2 2 255<br>255 255 255<br>102 204 255<br>57 197 187<br>0 0 0</p></blockquote><p>Ҳ���԰�������ѹ��һ�С�<br>���ǿ��Խ�������$256$����������ôÿ�����ص������Դ�$0$��$255\times65536+255\times256+255=2^{24}-1$������</p><p>�����Ҫ��������ݸ��������������������Ӽ�������������档<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">O</span><span class="params">(<span class="string">"1.ppm"</span>)</span></span>;</span><br><span class="line">O&lt;&lt;<span class="string">"P3 "</span>&lt;&lt;h&lt;&lt;<span class="string">" "</span>&lt;&lt;w&lt;&lt;<span class="string">" 255"</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++)</span><br><span class="line">O&lt;&lt;<span class="string">" "</span>&lt;&lt;a[i][j].r&lt;&lt;<span class="string">" "</span>&lt;&lt;a[i][j].g&lt;&lt;<span class="string">" "</span>&lt;&lt;a[i][j].b;</span><br></pre></td></tr></table></figure></p><p>���ǿ��������Ƶķ����������ݴ���Ϊ<code>wav</code>�ļ�����Ϊ��������������Ժ���ʱ����˵��</p><h2 id="4-��ѧ��"><a href="#4-��ѧ��" class="headerlink" title="(4)��ѧ��"></a>(4)��ѧ��</h2><p>���ұ�<code>�й����� ����ս��</code>��ʱ������Ҫ�����ģ�Ȼ��$RioBlu$���ҽ�����һ�ּ��ܴ󷨣�ֻ����ȫ�Ƿ��ţ�����а�Ƿ���������ܽ���������<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"��¬��ΰû�п���"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)O&lt;&lt;s[i]&lt;&lt;<span class="string">" "</span>;</span><br></pre></td></tr></table></figure></p><p>�������г����ʱ���㿴�浵�ᷢ�ֶ���һ�������ƵĶ�����������Ϊ���ȫ�Ƿ��Ų�����ݣ��ͻ������룬���ǻ��ǿ��Զ���ģ�<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> v=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">char</span> ch=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span>(I&gt;&gt;ch)v+=ch;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v;</span><br></pre></td></tr></table></figure></p><p>�Ҿ������ַ���ͦ���������ҵ����������������<del>Ҳ��֪��Ϊʲô</del>��ֻҪ��һ�Ĵ浵���������̾ͻ������룬�������ʲô�����������Ļ��������������롣<br><a href="https://share.weiyun.com/5KyEqcF" target="_blank" rel="noopener">����һ��</a>������<code>iloveu</code>���浵��ͬ�ļ��е�<code>chess\data\</code>���棬�ļ��������ˣ�</p><h1 id="4-��ȡ�ж�"><a href="#4-��ȡ�ж�" class="headerlink" title="4.��ȡ�ж�"></a>4.��ȡ�ж�</h1><p>�ڶ�ȡ��ʱ������жϣ������ȡ����Ϣ����Ϸ�趨�����ϣ��������Ǹ���������ôֱ��ɾ���浵��</p><p>$RioBlu$��<code>ͳһ����</code>Ҳ�������������������Ϊ����������̫��������ɸ��������ͻ�����һЩ������뿨���ԣ������Ӻ���̫��<del>��˭������Ҵ浵</del>����</p><h1 id="5-����"><a href="#5-����" class="headerlink" title="5.����"></a>5.����</h1><p>������ɺ���͵�һ�ء��ܺ��ӡ��������Լ��Ĵ浵�᲻������ױ��۸ġ�</p><p>��Ҳ���Խ�����ĺ�������һ����ԡ�</p><h1 id="6-С��"><a href="#6-С��" class="headerlink" title="6.С��"></a>6.С��</h1><p>ֻҪ���ܺܺõؽ����漸�����ã���������Ĵ浵���ᱻ�۸ġ�</p><hr><script type="math/tex; mode=display">\Huge The\ End</script>]]></content>
      
      
      <categories>
          
          <category> �̳� </category>
          
      </categories>
      
      
        <tags>
            
            <tag> �̳� </tag>
            
            <tag> ��Ϸ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何找单峰函数峰值</title>
      <link href="/2019/%E5%A6%82%E4%BD%95%E6%89%BE%E5%8D%95%E5%B3%B0%E5%87%BD%E6%95%B0%E5%B3%B0%E5%80%BC/"/>
      <url>/2019/%E5%A6%82%E4%BD%95%E6%89%BE%E5%8D%95%E5%B3%B0%E5%87%BD%E6%95%B0%E5%B3%B0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>$By\ King$</p><p>找单峰函数的峰值有什么用？ 怎么找单峰函数的峰值？</p><p>别急，让这篇文章来告诉你。</p><a id="more"></a><h1 id="1-什么是单峰函数？"><a href="#1-什么是单峰函数？" class="headerlink" title="$1.$什么是单峰函数？"></a>$1.$什么是单峰函数？</h1><p>肯定要先听听度娘的解释啦！</p><blockquote><p>单峰函数是在所考虑的区间中只有一个严格局部极大值$($峰值$)$的实值函数。如果函数$f(x)$在区间$[a, b]$上只有唯一的最大值点$C$，而在最大值点$C$的左侧，函数单调增加；在点$C$的右侧，函数单调减少，则称这个函数为区间$[a, b]$上的单峰函数。——<a href="https://baike.baidu.com/item/%E5%8D%95%E5%B3%B0%E5%87%BD%E6%95%B0/7544838?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p></blockquote><p>引用百度的原图大概的说一下：</p><p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=9e52f76d4036acaf4ded9eae1db0e675/0824ab18972bd407604767a970899e510eb309e5.jpg" alt></p><p>就是函数$f(x)$有一个最高点$x_0$（如图），然后它的右边单调下降，左边单调上升。</p><p>也可以这样解释：</p><p>如果$f(x)$最大：</p><ul><li>如果$a&lt;b&lt;x$，那么$f(b)\ge f(a)$。</li><li>如果$x&gt;a&gt;b$，那么$f(a)\ge f(b)$。</li></ul><hr><p>寻找一个单峰函数的峰值有什么用？</p><ul><li>某些$OI$题会让你求一个单峰函数的峰值，例如<a href="http://poj.org/problem?id=2420" target="_blank" rel="noopener">POJ2420</a>、<a href="http://poj.org/problem?id=3737" target="_blank" rel="noopener">POJ3737</a>、<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2340" target="_blank" rel="noopener">ZOJ2340</a>等。甚至洛谷还有一道<a href="https://www.luogu.org/problem/P3382" target="_blank" rel="noopener">模板题</a>。</li><li>生活中的很多东西都是这样，大了也不好，小了也不好，不多不少的时候最好。我最喜欢举的例子是，粉笔短了不好写且用得快，粉笔长了又容易断；为了贯彻拿$MM$打比方的精神，这里可以再举一些例子来说明这一情况的普遍性：陪$MM$出去玩的次数多了很快会腻，陪$MM$次数少了又会疏远；把握火候贯彻“半糖主义”方针是非常重要的。事实上，从硬盘缓存的大小到初期农民的个数，从每学期的学分到论文的长度，生活中几乎所有东西都是这样，就连饭量和睡眠时间也是。这些例子说穿了就是一个单峰函数，我们需要用尽可能少的试验次数快速找到极大点。永远不要以为决策者们面对的都是高中数学考卷上的“每涨$10$块钱就会少$100$个消费者”一类的屁话，这些屁话都是用来编二次函数题目的。现实生活中企业做决策时，样点实验、不断取舍、逐步逼近最优点仍然是最实在最有效的手段。——$Matrix67$</li><li>奥数题，这是真的。<del>只要那是填空题</del></li></ul><h1 id="2-怎么找单峰函数的峰值？"><a href="#2-怎么找单峰函数的峰值？" class="headerlink" title="$2.$怎么找单峰函数的峰值？"></a>$2.$怎么找单峰函数的峰值？</h1><h2 id="0-注意"><a href="#0-注意" class="headerlink" title="$(0)$注意"></a>$(0)$注意</h2><p>本节中以$f(x)$为代码中的单峰函数。左端点和右端点为$0$和$10$。</p><p>这里使用$f(x)=\sqrt[x]{x}$。$f(x)$峰值为$\sqrt[e]{e}$，约等于$1.444667861$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(x,<span class="number">1</span>/x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-暴力枚举"><a href="#1-暴力枚举" class="headerlink" title="$(1)$暴力枚举"></a>$(1)$暴力枚举</h2><p>最普通的方法肯定是暴力啦！</p><p>这个不用说了吧，设置步长，从左到右扫记录最大值。</p><p><strong>优点：相对稳定。</strong></p><p><strong>缺点：耗时长，精度低。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pre=<span class="number">2</span>;<span class="comment">//精度可调</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p=<span class="built_in">pow</span>(<span class="number">10</span>,-pre);<span class="comment">//计算步长</span></span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">10</span>,maxx=<span class="number">-1</span>;<span class="comment">//看情况来定maxx的初始值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> i=l+pre;i&lt;=r;i+=p)<span class="comment">//由于使用x^(1/x)为f函数，所以i不能为0</span></span><br><span class="line">    maxx=max(maxx,f(i));<span class="comment">//寻找最大值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(10^n)$，照着这样，$1$秒只能算到$7$位数左右。</p><h2 id="2-三分查找-1"><a href="#2-三分查找-1" class="headerlink" title="$(2)$三分查找$1$"></a>$(2)$三分查找$1$</h2><p>像这种带有单调性的函数，让人不由自主的想起——二分。</p><p>但是我们不能只取一个点，因为这是无法得出峰值在哪里的，所以我们需要取两个点，通过比较这两个点来得出峰值的位置。</p><p>阮大佬曾在<a href="http://ruanx.pw/post/%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE.html" target="_blank" rel="noopener">他的博客</a>中介绍了三分查找，主要是分一半再分一半的思想（$mid$是$l$和$r$的中点，$mmid$是$mid$和$r$的中点）。如图：</p><p><img src="https://s2.ax1x.com/2019/07/25/em1eud.png" alt></p><p>比较$f(mid)$和$f(mmid)$的值：</p><ul><li>当$f(mid)&gt;f(mmid)$的值时，使$r=mmid$。即峰值必在$midd$左边。</li><li>当$f(mid)&lt;f(mmid)$时，使$l=mid$。即峰值必在$mid$右边。</li></ul><p>证明在链接里有，这里就照着我的思路再讲一遍吧（其实是差不多的）：</p><p>当$f(mid)&gt;f(mmid)$的值时，若峰值在$midd$右边，会导致有$2$个峰（否则$f(mid)$不会大于$f(mmid)$），所以峰值必在$midd$左边。</p><p>同样可以证第二个。</p><p>既然这样，我们就可以进行三分，每次可以舍去原长度的$\frac{1}{2}$或$\frac{1}{4}$。</p><p>那么时间复杂度最优$O(2\log<em>2n)$，最坏$O(2\log</em>\frac{4}{3}n)$。</p><p>另外，在链接里有提及到写法，一种是<code>控制迭代次数</code>，一种是<code>直接控制精度</code>，接下来的本节的代码都是<code>直接控制精度</code>。</p><p><strong>优点：速度快。</strong></p><p><strong>缺点：不稳定。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pre=<span class="number">10</span>;<span class="comment">//设置精度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> p=<span class="built_in">pow</span>(<span class="number">10</span>,-pre);<span class="comment">//计算精度限制</span></span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">10</span>,mid,mmid;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;p)&#123;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;<span class="comment">//计算mid</span></span><br><span class="line">        mmid=(mid+r)/<span class="number">2</span>;<span class="comment">//计算mmid</span></span><br><span class="line"><span class="keyword">if</span>(f(mid)-f(mmid)&gt;=<span class="number">0</span>)r=mmid;<span class="comment">//大于时舍去右边</span></span><br><span class="line"><span class="keyword">if</span>(f(mid)-f(mmid)&lt;=<span class="number">0</span>)l=mid;<span class="comment">//小于时舍去左边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;max(f(l),f(r));<span class="comment">//输出更大的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有一个问题：</p><p>代码中$10$到$11$行中，照着思路来说，应该是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f(mid)-f(mmid)&gt;<span class="number">0</span>)r=mmid;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br></pre></td></tr></table></figure><p>为什么要换成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f(mid)-f(mmid)&gt;=<span class="number">0</span>)r=mmid;</span><br><span class="line"><span class="keyword">if</span>(f(mid)-f(mmid)&lt;=<span class="number">0</span>)l=mid;</span><br></pre></td></tr></table></figure><p>因为我在测试的过程中，发现若换成带<code>else</code>的代码，那么当$pre&gt;15$的时候，由于$C++$的精度问题会将$\frac{x+r}{2}$的值算成$l$（$x$很接近$l$），那么就会算出$mid=l$，然后又算出$mmid=l$。那么$mid=mmid$就算出了$f(mid)-f(mmid)$等于$0$，那么就会执行<code>else</code>后的语句$l=mid$，然而$mid$本来就等于$l$，也就是说什么都没有变，最终导致了死循环。</p><p>另外，我们并没有提到过当$f(mid)=f(midd)$时的情况，因为在此时峰值三种情况都有可能（如图），所以只能靠“蒙”。</p><p><img src="https://s2.ax1x.com/2019/07/26/entjhR.png" alt><br>然而度娘告诉我们：我们应该“蒙”中间，也就是说把左右都去掉（如图）：</p><p><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=07ed2748514e9258b2398ebcfdebba3d/8718367adab44aed20bd71c8b41c8701a18bfb2f.jpg" alt></p><p>于是就有了这样一段代码。</p><h2 id="3-三分查找-2"><a href="#3-三分查找-2" class="headerlink" title="$(3)$三分查找$2$"></a>$(3)$三分查找$2$</h2><p>为了让算法变得更稳定，我们可以把这两个点设在三等分处，这样每次都一定会舍弃原长度的$\frac{1}{3}$。时间复杂度$O(2log_3n)$。</p><p><img src="https://s2.ax1x.com/2019/07/26/en0hh4.png" alt></p><p><strong>优点：速度快，相对更稳定。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pre=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> p=<span class="built_in">pow</span>(<span class="number">10</span>,-pre);</span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">10</span>,m1,m2;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;p)&#123;</span><br><span class="line">        m1=(l+r+l)/<span class="number">3</span>;</span><br><span class="line">        m2=(l+r+r)/<span class="number">3</span>;<span class="comment">//这两句需要注意！！！</span></span><br><span class="line"><span class="keyword">if</span>(f(m1)-f(m2)&gt;=<span class="number">0</span>)r=m2;</span><br><span class="line"><span class="keyword">if</span>(f(m1)-f(m2)&lt;=<span class="number">0</span>)l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;max(f(l),f(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中有一处是需要注意的。</p><p><strong>千万不要写成m1=(l+r)3和m2=(l+r)2/3！！</strong></p><p>很多人认为二分时$m=\frac{1}{2}(l+r)$，然而自然就想到三分是应该是$\frac{1}{3}(l+r)$和$\frac{2}{3}(l+r)$</p><p>这样写是错误的，例如$l=3,r=4$的时候$m1=\frac{7}{3}=2.333\dots,m2=\frac{14}{3}=4.666\dots$。根本不在$l$和$r$的范围内！</p><p>因为我们截取的是一段，所以原长度的$\frac{1}{3}$应该是$\frac{r-l}{3}$，也就是说$m1$应该是$l+\frac{r-l}{3}=\frac{2l+r}{3}$，$m2=r-\frac{r-l}{3}=\frac{2r+l}{3}$。</p><p>那为什么二分是$m=\frac{l+r}{2}$？</p><p>其实也是一样的道理，$m=l+\frac{r-l}{2}=\frac{l+r}{2}$。</p><h2 id="4-“二分查找”"><a href="#4-“二分查找”" class="headerlink" title="$(4)$“二分查找”"></a>$(4)$“二分查找”</h2><p>我们发现只要$m1$到$l$的距离和$m2$的到$r$距离相等，算法就会稳定。如果我们想需要速度更快，应该怎么处理呢？</p><p>可以想到我们如果把$m1$和$m2$取得接近于中点，那么一次比较就可以舍去几乎$\frac{1}{2}$的长度了！</p><p>如图中（$C$是一个较小的常数）：<br><img src="https://s2.ax1x.com/2019/07/26/enBvZV.png" alt></p><p><strong>优点：速度比普通三分快</strong></p><p><strong>缺点：语言浮点运算误差必须小</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pre=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> p=<span class="built_in">pow</span>(<span class="number">10</span>,-pre);</span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">10</span>,m;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;=p)&#123;</span><br><span class="line">m=(l+r)/<span class="number">2</span>;<span class="comment">//取中点 </span></span><br><span class="line"><span class="keyword">if</span>(f(m-p)-f(m+p)&gt;=<span class="number">0</span>)r=m;</span><br><span class="line"><span class="keyword">if</span>(f(m-p)-f(m+p)&lt;=<span class="number">0</span>)l=m;<span class="comment">//比较中点两端 </span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;max(f(l),f(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：如果常数$C$太小，那么$C++$就会将$mid-C$和$mid+C$看作相等，然后$l=mid,r=mid$，然后结束循环，最终你得到的答案只是$f(mid)$的值。</strong></p><p>时间复杂度大约是$O(\log_2n)$。</p><h2 id="5-求导-二分"><a href="#5-求导-二分" class="headerlink" title="$(5)$求导$+$二分"></a>$(5)$求导$+$二分</h2><p>为什么可以这样做？</p><p>如果你学过高中数学，你会知道导数的零点就是原函数的峰值。</p><p>因为是单峰，所以只需要找$l$和$r$之间的使$f(x)$为$0$的数。</p><p>那么问题就转化成了二分</p><p>做法：</p><p>首先，你需要先对函数<a href="https://baike.baidu.com/item/%E5%AF%BC%E6%95%B0%E8%A1%A8/10889755#1" target="_blank" rel="noopener">求导</a>。</p><p>个人不太支持这种，毕竟复杂的函数很难求导，如果是多项式求导就比较简单一些，直接用幂函数求导公式。</p><script type="math/tex; mode=display">a_0+a_1x+a_2x^2+\dots+a_{n-1}x^{n-1}+a_nx^n</script><p>求导后是</p><script type="math/tex; mode=display">a_1+2a_2x+3a_3x^2+\dots+na_nx^{n-1}</script><p><strong>优点：用着舒服，基本不会出$bug$</strong></p><p><strong>缺点：复杂函数难求导</strong></p><p>这里给出<a href="https://www.luogu.org/problem/P3382" target="_blank" rel="noopener">P3382 【模板】三分法</a>的求导$+$二分的代码（$\sqrt[x]{x}$求导太难了<del>其实是不会</del>）</p><p>因为懒，我这里直接放出<a href="https://www.luogu.org/space/show?uid=100514" target="_blank" rel="noopener">小黑AWM大佬</a>的<a href="https://andrewwayne.blog.luogu.org/solution-p3382" target="_blank" rel="noopener">题解</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">20</span>],L,R,k;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) ans=ans*x+a[i];<span class="comment">//常数项没了</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lf%lf"</span>,&amp;n,&amp;L,&amp;R);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;i--)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i]),a[i]*=i;<span class="comment">//a[i]*=i求导</span></span><br><span class="line"><span class="keyword">while</span>(R-L&gt;=<span class="number">1e-6</span>)&#123;<span class="comment">//二分</span></span><br><span class="line"><span class="keyword">double</span> mid=(R+L)/<span class="number">2</span>;</span><br><span class="line">    f(mid)&gt;<span class="number">0</span>?L=mid:R=mid;<span class="comment">//等价于if(f(mid)&gt;0)L=mid;else R=mid;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>,L);<span class="comment">//输出答案</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-0-618-法"><a href="#6-0-618-法" class="headerlink" title="$(6)0.618$法"></a>$(6)0.618$法</h2><p>然而这些做法都不能很好地优化。（除了求导二分）</p><p>最好的做法是循环利用上一次比较时剩下的点。使一个点被去掉后另一个点正好是下一次比较的其中一个点。这就是<a href="https://baike.baidu.com/item/0.618%E6%B3%95/7238973?fr=aladdin" target="_blank" rel="noopener">$0.618$法</a>，是<a href="https://baike.baidu.com/item/%E4%BC%98%E9%80%89%E6%B3%95/3111033?fr=aladdin" target="_blank" rel="noopener">优选法</a>的其中一种。</p><p>那么这两个点应该取在哪里呢？</p><p>$A$点在$B$点去掉后的那一段上的位置与$B$点原先在整段上所处的位置比例相同,那么这个比例通过计算得出：<br><img src="https://s2.ax1x.com/2019/07/26/enWnF1.png" alt></p><p>$\frac{a}{b}$约等于$0.618$。</p><p>那么$a=\frac{r-l}{1+\frac{1+\sqrt{5}}{2}}$，也就是是$\frac{r-l}{\phi+1}$。</p><p>这样，我们就确定了两个点的位置了。</p><p><strong>优点：重复利用测试点，速度极快。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 0.38196601125010515179541316563436<span class="comment">//1-φ</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pre=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> p=<span class="built_in">pow</span>(<span class="number">10</span>,-pre);</span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">10</span>,m1=l+F*(r-l),m2=r-F*(r-l);</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;p)&#123;</span><br><span class="line"><span class="keyword">if</span>(f(m1)&gt;=f(m2))&#123;</span><br><span class="line">r=m2;<span class="comment">//去掉右边</span></span><br><span class="line">m2=m1;<span class="comment">//替换</span></span><br><span class="line">m1=l+F*(r-l);<span class="comment">//计算新的m1</span></span><br><span class="line"><span class="keyword">if</span>(f(m1)&gt;f(m2))<span class="keyword">continue</span>;<span class="comment">//如果等于先不要结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f(m1)&lt;=f(m2))&#123;</span><br><span class="line">l=m1;<span class="comment">//去掉左边</span></span><br><span class="line">m1=m2;<span class="comment">//替换</span></span><br><span class="line">m2=r-F*(r-l);<span class="comment">//计算新的m2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;f(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-本节小结"><a href="#7-本节小结" class="headerlink" title="$(7)$本节小结"></a>$(7)$本节小结</h2><h3 id="I-哪种算法更好？"><a href="#I-哪种算法更好？" class="headerlink" title="$I.$哪种算法更好？"></a>$I.$哪种算法更好？</h3><p>应该是$0.618$法了。</p><p>如果说函数比较方便求导，那肯定推荐求导二分，毕竟只需要$log_2n$的时间。</p><p>附带一张图关于以上的算法的速度（没有写求导二分）：</p><p>$\color{orange}{暴力枚举}\color{black}{、}\color{purple}{三分查找1}\color{black}{、}\color{green}{三分查找2}\color{black}{、}\color{blue}{“二分查找”}\color{black}{、}\color{red}{0.618法}$</p><p><img src="https://s2.ax1x.com/2019/07/30/eGOJtH.png" alt></p><p>$Draw\ by\ GeoGebra$</p><h3 id="II-其他玄学的方法"><a href="#II-其他玄学的方法" class="headerlink" title="$II.$其他玄学的方法"></a>$II.$其他<del>玄学的</del>方法</h3><p>直接看<a href="https://www.luogu.org/problemnew/solution/P3382" target="_blank" rel="noopener">P3382的题解</a>你就会发现有很多玄学大法：什么<a href="https://www.luogu.org/blog/yuy/solution--p3382" target="_blank" rel="noopener">粒子群优化</a>啊、<a href="https://www.luogu.org/blog/Hakuryu/p3382-san-fen-fa-mu-ni-tui-huo" target="_blank" rel="noopener">模拟退火</a>啊、<a href="https://ouuan.blog.luogu.org/solution-p3382" target="_blank" rel="noopener">梯度下降法</a>啊、甚至还出现了<a href="https://youngsc.blog.luogu.org/solution-p3382" target="_blank" rel="noopener">四分</a>。</p><h3 id="III-小优化"><a href="#III-小优化" class="headerlink" title="$III.$小优化"></a>$III.$小优化</h3><p>若题目要求多项式的峰值，可以通过<a href="https://baike.baidu.com/item/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95/449196?fr=aladdin" target="_blank" rel="noopener">秦九韶算法</a>简化多项式，从而使效率更高。</p><p>多项式$a_0+a_1x+a_2x^2+a_3x^3+\dots+a_nx^n$，若直接计算，则需要进行$\frac{n(n+1)}{2}$乘法和$n$次加法。</p><p>但是我们学过乘法分配律，你会发现除$a_0$项外每项都带有$x$，那么分配起来：$a_0+x(a_1+a_2x+a_3x^2+\dots+a_nx^{n-1})$</p><p>在括号内除$a_1$项外都含有$x$，再次分配：$a_0+x(a_1+x(a_2+a_3x+\dots+a_nx^{n-2}))$</p><p>以此类推，最后就会变成：$a<em>0+x(a_1+\dots+x(a</em>{n-2}+x(a_{n-1}+a_nx)))$。这个式子最终只需要进行$n$次乘法和$n$次加法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">ans+=a[i]*<span class="built_in">pow</span>(x,i);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="comment">//普通算法</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)ans=ans*x+a[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="comment">//秦九韶算法</span></span><br></pre></td></tr></table></figure><h1 id="3-例题"><a href="#3-例题" class="headerlink" title="$3.$例题"></a>$3.$例题</h1><h2 id="1-原创题目"><a href="#1-原创题目" class="headerlink" title="$(1)$原创题目"></a>$(1)$原创题目</h2><p>题意：给你一张边长为$n$的正方形纸，在四个角落各剪一个边长为$x$的小正方形$(0&lt;x&lt;\frac n2)$，拼成一个无盖长方体，请输出这个长方体体积最大时的体积、高和底面正方形的边长（保留$5$位小数）。</p><p><img src="https://s2.ax1x.com/2019/07/30/eJJYIP.png" alt></p><p>我们知道，它的体积是$x(n-2x)^2$，可以知道当$x=0$和$x=\frac n2$时体积为$0$（还有一个$x=\frac n2$是<a href="https://baike.baidu.com/item/%E9%87%8D%E6%A0%B9/5030500?fr=aladdin" target="_blank" rel="noopener">重根</a>），那么$0$到$\frac n2$之间一定只有一个峰。类似下图：</p><p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=39b5a4918b0a19d8df0e8c575293e9ee/cc11728b4710b9123df60bdec8fdfc03924522df.jpg" alt></p><p>所以可以用三分，三分$x$的长度（即三分盒子的高）。</p><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> n,l,r,m1,m2;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*(n<span class="number">-2</span>*x)*(n<span class="number">-2</span>*x);<span class="comment">//返回体积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">r=n/<span class="number">2.0</span>;<span class="comment">//题目说了x&lt;n/2</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1e-7</span>)&#123;</span><br><span class="line">        m1=(l+r+l)/<span class="number">3</span>;</span><br><span class="line">        m2=(l+r+r)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(f(m1)-f(m2)&gt;=<span class="number">0</span>)r=m2;</span><br><span class="line"><span class="keyword">if</span>(f(m1)-f(m2)&lt;=<span class="number">0</span>)l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">5</span>)&lt;&lt;f(l)&lt;&lt;<span class="string">" "</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="built_in">sqrt</span>(f(l)/l);<span class="comment">//a*a*h=f(h)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你测试几个测试点的时候，你就会发现答案似乎是一些循环小数。</p><p>确实是这样，这里是公式$V=\frac{2n^3}{27},h=\frac n6,a=\frac{2n}{3}$，所以：</p><p><del>正解</del>就有另一种解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">5</span>)&lt;&lt;<span class="number">2</span>*n*n*n/<span class="number">27</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;n/<span class="number">6</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="number">2</span>*n/<span class="number">3</span>;<span class="comment">//直接套用公式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-POJ3737-UmBasketella"><a href="#2-POJ3737-UmBasketella" class="headerlink" title="$(2)$POJ3737-UmBasketella"></a>$(2)$POJ3737-UmBasketella</h2><p>题意：输入圆锥表面积$S$，输出其最大体积，以及此时圆锥的高和底面半径。</p><p>先证明它是单峰函数（只看正数部分）：</p><p><img src="https://s2.ax1x.com/2019/07/27/eKTW5D.png" alt></p><p>$Draw\ by\ $<a href="https://www.geogebra.org/graphing/jtehwrxe" target="_blank" rel="noopener">$GeoGebra$</a></p><p>这只是其中的$S=1$的情况<del>我也不会证只是给你们看一下知道是就行</del></p><p>圆锥表面积公式：$S=\pi r(r+\sqrt{r^2+h^2})$</p><p>圆锥体积公式：$V=\frac{1}{3}\pi r^2h$</p><p>知道这些后，就可以开始三分了。</p><p>做法：三分$r$的值。通过表面积$S$和$r$计算出$h$的值，再通过$r$和$h$计算出圆锥的体积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;//poj不给用万能头QAQ</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI acos(-1)</span></span><br><span class="line"><span class="comment">/*上面这句其实可以不加，因为math.h里有，但如果不加在poj就会CE*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> S,V,H;<span class="comment">//表面积，体积，高</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> R)</span></span>&#123;</span><br><span class="line">H=<span class="built_in">sqrt</span>((S/(M_PI*R)-R)*(S/(M_PI*R)-R)-R*R);<span class="comment">//通过表面积和底面半径算出高</span></span><br><span class="line">V=M_PI*R*R*H/<span class="number">3</span>;<span class="comment">//先存到V里</span></span><br><span class="line"><span class="keyword">return</span> V;<span class="comment">//返回体积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;S)&#123;<span class="comment">//有多个数据</span></span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="built_in">sqrt</span>(S/M_PI),m1,m2,t=<span class="number">50</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="comment">/*因为表面积是πr(r+l)那么r大概就是sqrt(表面积/π)*/</span></span><br><span class="line"><span class="keyword">while</span>(t--)&#123;<span class="comment">//控制迭代次数，50次</span></span><br><span class="line">m1=(l+l+r)/<span class="number">3</span>;</span><br><span class="line">m2=(l+r+r)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(f(m1)&lt;f(m2))l=m1;</span><br><span class="line"><span class="keyword">else</span> r=m2;</span><br><span class="line"><span class="comment">/*这部分基本一样*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;V&lt;&lt;<span class="built_in">endl</span>&lt;&lt;H&lt;&lt;<span class="built_in">endl</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//照题意输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你也可以三分$h$的值，只是通过$S$和$h$的值比较难求出$r$的值。</p><h2 id="3-本章小结"><a href="#3-本章小结" class="headerlink" title="$(3)$本章小结"></a>$(3)$本章小结</h2><p>其实一般的三分题，只需要：</p><ol><li>记住模板</li><li>选择要三分的数</li><li>修改<code>f(x)</code>函数</li><li>设置好左端点和右端点</li><li>调整精度</li></ol><p>就可以轻松$AC$。如果你想做更多三分题，<a href="https://blog.csdn.net/consciousman/article/details/53045734" target="_blank" rel="noopener">戳我</a>。</p><h1 id="4-结束"><a href="#4-结束" class="headerlink" title="$4.$结束"></a>$4.$结束</h1><p>蒟蒻第一次写文章，可能还不够熟练，如果文章有什么问题欢迎各位大佬指正，如果有什么漏掉的也欢迎各位大佬补充！</p><p>参考：</p><ul><li><a href="http://www.matrix67.com/blog/archives/1057" target="_blank" rel="noopener">漫话二分（下）| Matrix67: The Aha Moments</a></li><li><a href="http://ruanx.pw/post/%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE.html" target="_blank" rel="noopener">三分查找 - blue’s blog</a></li><li><a href="https://baike.baidu.com/item/%E5%8D%95%E5%B3%B0%E5%87%BD%E6%95%B0/7544838?fr=aladdin" target="_blank" rel="noopener">单峰函数_百度百科</a></li><li><a href="https://baike.baidu.com/item/0.618%E6%B3%95/7238973?fr=aladdin" target="_blank" rel="noopener">0.618法_百度百科</a></li><li><a href="https://baike.baidu.com/item/%E4%BC%98%E9%80%89%E6%B3%95/3111033?fr=aladdin" target="_blank" rel="noopener">优选法_百度百科</a></li><li><a href="https://baike.baidu.com/item/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95/449196?fr=aladdin" target="_blank" rel="noopener">秦九韶算法_百度百科</a></li><li><a href="https://baike.baidu.com/item/%E9%87%8D%E6%A0%B9/5030500?fr=aladdin" target="_blank" rel="noopener">重根（数学代数名词）_百度百科</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黄金分割 </tag>
            
            <tag> 单峰函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭开虚数i的神秘面纱</title>
      <link href="/2019/%E6%8F%AD%E5%BC%80%E8%99%9A%E6%95%B0i%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/"/>
      <url>/2019/%E6%8F%AD%E5%BC%80%E8%99%9A%E6%95%B0i%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/</url>
      
        <content type="html"><![CDATA[<p>$By\ King$</p><blockquote><p>$e^{i\pi}+1=0$</p></blockquote><a id="more"></a><h1 id="1-i-是什么？"><a href="#1-i-是什么？" class="headerlink" title="$1.i$是什么？"></a>$1.i$是什么？</h1><p>如果按照<a href="https://baike.baidu.com/item/%E8%99%9A%E6%95%B0%E5%8D%95%E4%BD%8D/6803458?fr=aladdin#2" target="_blank" rel="noopener">数字定义</a>，$i^2=-1$，$i^3=-i$，$i^4=1$，$i^5=i$，$i^6=-1\dots$，你会发现$i$的幂每四个为一个循环，得出$i^{4n}=1$，$i^{4n+1}=i$，$i^{4n+2}=-1$，$i^{4n+3}=-i(n\in\mathbb{N})$</p><p>让我们引入一种全新的解释：它可以是一个旋转量。$i$是旋转$90^\circ$。</p><p>假如有一个实数数轴，在原点处又有一条数轴垂直于实数数轴，然后从$1$旋转$90^\circ$，就变成了$i$，再旋转$90^\circ$就变成了$-1$，因为乘法是充当着旋转的作用，而加减法是平移。</p><p>看下面的图你就知道了：</p><p><img src="https://s2.ax1x.com/2019/07/16/ZHMYNt.png" alt></p><p>这样是不是更好理解呢？</p><p>可能会有一些人不信$i$这种东西，就像在$18$世纪的欧洲数学家一样，他们不相信负数。</p><p>就像我们刚学会正数一样，只会加法，</p><p>后来懂了减法，但是$1-2=?$，于是我们就学会了负数，因此得知$1-2=-1$。</p><p>学了除法后，我们又懂得了什么是分数；学了$\pi$和根号后，又知道了什么是无理数。</p><p>任何事并不是有意义的，就像刚开始时人们认为$1-2$是无意义的，毕达哥拉斯认为$\sqrt{2}$是没有意义的一样。</p><blockquote><p>当我们发明某些东西时，我们的智力会有突飞猛进的进步。</p></blockquote><h1 id="2-e-i-pi-1-0"><a href="#2-e-i-pi-1-0" class="headerlink" title="$2.e^{i\pi}+1=0$"></a>$2.e^{i\pi}+1=0$</h1><p>这是十分著名的欧拉恒等式，它被称为最完美的公式，为什么呢？</p><blockquote><p>上帝创造的公式，我们只能看它而不能理解它。</p></blockquote><p>这个公式，涉及到了数学中几个著名的常数，将数学的各个分支结合到了一起。</p><ul><li>$e$，自然对数的底，它是个无理数，在高等数学、物理学中很常用，与增长息息相关，它等于$2.718281828459045\dots$，这有个好方法来记住前$15$位，是李永乐老师教的，首先是$2$个$1828$，然后是等腰直角三角形的三个内角的度数：$45$，$90$和$45$。计算$e$的公式有个比较简单的：$(1+\frac1{n})^n$，当$n$越大的时候，这个式子会越接近$e$，类似地，$e^x=(1+\frac{x}{n})^n$，顺带一提，$e^x$的导数是本身。</li><li>$\pi$，圆周率，也是个无理数，在几何中很常见，有$\pi$的地方就肯定有圆，相信大家小学就学过（这让我想起了小学背$2\pi=6.28$，$3\pi=9.42\dots$的恐惧，），它等于$3.1415926535897932\dots$，这里也有一个公式来计算它：$n\times\sin(\frac{180^\circ}{n})$，同样，当$n$越大的时候式子会越接近$\pi$，至于这个公式的推导，是类似于割圆法的思想，我会在以后的一篇博客上讲到。</li><li>$i$，虚数单位，这里就不多说了吧，刚刚讲完。</li><li>$1$，正整数的单位，$1$的$n$次方都等于$1(n\in\mathbb{R})$，而且任何数乘$1$都是本身。</li><li>$0$，最小的自然数，任何数加$0$都是本身。</li></ul><p>$The\ Mathematical\ Intelligencer$杂志举办过一次读者投票关于史上最美的公式，欧拉恒等式被当选。</p><p>这就是它为什么这么美的原因。</p><p>接下来，我们是得出这个公式的呢？</p><p><strong>请注意，接下来将会涉及到三角函数(弧度模式下)</strong></p><p>首先如果你了解泰勒公式，你肯定知道这三条式子</p><script type="math/tex; mode=display">e^x=\sum\limits_{i=0}^\infty(\frac{x^i}{i!})=\frac{x^0}{0!}+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}\dots</script><script type="math/tex; mode=display">\cos x=\sum\limits_{i=0}^\infty((-1)^i\frac{x^{2i}}{(2i)!})=\frac{x^0}{0!}-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^8}{8!}\dots</script><script type="math/tex; mode=display">\sin x=\sum\limits_{i=0}^\infty((-1)^i\frac{x^{2i+1}}{(2i+1)!})=\frac{x^1}{1!}-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\frac{x^9}{9!}\dots</script><p>由第一条式子代入$ix$，得出</p><script type="math/tex; mode=display">e^{ix}=\frac{i^0x^0}{0!}+\frac{i^1x^1}{1!}+\frac{i^2x^2}{2!}+\frac{i^3x^3}{3!}+\frac{i^4x^4}{4!}\dots</script><p>我们在开头说了$i$的幂是以四个为一循环的，于是</p><script type="math/tex; mode=display">e^{ix}=\frac{x^0}{0!}+\frac{ix^1}{1!}+\frac{-x^2}{2!}+\frac{-ix^3}{3!}+\frac{x^4}{4!}\dots</script><script type="math/tex; mode=display">e^{ix}=\frac{x^0}{0!}+\frac{ix^1}{1!}-\frac{x^2}{2!}-\frac{ix^3}{3!}+\frac{x^4}{4!}\dots</script><p>分一下组，将不带有$i$的分为一组，其他的分为一组并把$i$提取出来</p><script type="math/tex; mode=display">e^{ix}=(\frac{x^0}{0!}-\frac{x^2}{2!}+\frac{x^4}{4!}\dots)+(\frac{ix^1}{1!}-\frac{ix^3}{3!}+\frac{ix^5}{5!}\dots)</script><script type="math/tex; mode=display">e^{ix}=(\frac{x^0}{0!}-\frac{x^2}{2!}+\frac{x^4}{4!}\dots)+i(\frac{x^1}{1!}-\frac{x^3}{3!}+\frac{x^5}{5!}\dots)</script><p>然后就可以代入第二和第三条式子了，式子变得简单起来</p><script type="math/tex; mode=display">e^{ix}=\cos x+i\sin x</script><p>再代入$x=\pi$，因为说了是弧度模式，所以$\cos\pi=-1$，$\sin\pi=0$。所以式子最终变成了</p><script type="math/tex; mode=display">e^{i\pi}=-1+i\times0</script><script type="math/tex; mode=display">e^{i\pi}=-1</script><script type="math/tex; mode=display">\Large e^{i\pi}+1=0</script><p>但如果你不懂什么是泰勒公式，可以看下面这么一个几何证明：</p><p>你首先要知道<a href="https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/2568041?fr=aladdin#2_1" target="_blank" rel="noopener">复数的乘法</a>表现为幅角相加，模长相乘。</p><p>那么$(1+2i)(1+2i)=-3+4i$，但$(1+2i)(1+2i)$在图中应怎么表示呢？</p><p>答案是这样的：</p><p>先在$0$，$1$，和$1+2i$这三个点构造三角形。</p><p><img src="https://s2.ax1x.com/2019/07/16/ZbWZRI.png" alt></p><p>然后复制这个三角形并旋转使他们贴合在一起。</p><p><img src="https://s2.ax1x.com/2019/07/16/ZbWnQP.png" alt></p><p>然后再把旋转后的三角形照比例缩放，使直角和上面的锐角在同一个点上。</p><p><img src="https://s2.ax1x.com/2019/07/19/ZvlErt.png" alt></p><p>最后旋转后的三角形的上面的锐角的顶点坐标就是$(1+2i)^2$也就是$-3+4i$了。</p><p>类似的，像上面的方法可以求出$(a+bi)^2$的值。回顾一遍：</p><ol><li>先在$0$，$1$，和$a+bi$这三个点构造三角形。</li><li>然后复制这个三角形并旋转使他们贴合在一起。</li><li>然后再把旋转后的三角形照比例缩放，使直角和上面的锐角在同一个点上。</li><li>最后旋转后的三角形的上面的锐角的顶点坐标就是$(a+bi)^2$了。</li></ol><p>用类似的方法我们可以求出$(a+bi)^n$，只需要在旋转后的三角形上再操作几次就行了。</p><p>还记得吗，在前面提到过一个公式，$e^x=(1+\frac{x}{n})^n$，当$n$越大的时候就会越精确。</p><p>那么如果我代入$x=i\pi$呢？</p><p>那么原式变成了$e^{i\pi}=(1+i\frac{\pi}{n})^n$，这有点像我们刚学的$(a+bi)^n$啊！没错，让我们来试一下，如果不出意外，最后的点会接近于$-1$，下面是$n=3$的情况：</p><p><img src="https://s2.ax1x.com/2019/07/19/ZvlVqP.png" alt></p><p>好像还离$-1$远得多呢！让我们试一试$n=10$吧。</p><p><img src="https://s2.ax1x.com/2019/07/16/ZqpPIJ.png" alt></p><p>嗯…接近了很多，但还是有点远，现在我们直接让$n=100$，看一下有多接近吧！</p><p><img src="https://s2.ax1x.com/2019/07/16/ZqpCa4.png" alt></p><p>不错，但是如果要让它更接近，这时应该将$n=\infty$，此时$e^{i\pi}=-1$，也就是说$e^{i\pi}+1=0$。</p><p>你也会发现，圆从$1$到$-1$的弧的长度正好是$\pi$！</p><p>综上所述，我们可以得到简短的证明：</p><blockquote><p>在平面内，从$1$开始，垂直增长$\pi$个单位变成$-1$，再加$1$变成$0$</p></blockquote><p><img src="https://s2.ax1x.com/2019/07/17/ZqqONq.png" alt></p><h1 id="3-关于-i-的实数"><a href="#3-关于-i-的实数" class="headerlink" title="$3.$关于$i$的实数"></a>$3.$关于$i$的实数</h1><h2 id="1-i-i"><a href="#1-i-i" class="headerlink" title="$1.i^i$"></a>$1.i^i$</h2><p>相信我，当你看到$i^i$的时候，你一定会以为是一个虚数，但是<strong>你错了</strong>，它是一个实数！</p><p>那么如何求出它呢？当然是用</p><script type="math/tex; mode=display">\Huge\text{欧拉恒等式}</script><p>当然要活学活用啊</p><p>首先我们知道$e^{i\pi}+1=0$，也就是说$e^{i\pi}=-1$，两边同时开方（相当于$\frac{1}{2}$次方）得到$e^{\frac{i\pi}{2}}=i$</p><p>继续两边同时$i$次方，我们就构造出了$i^i$，那么等式变成了$e^{\frac{i\pi}{2}i}=i^i$，右边变成$e^{\frac{i^2\pi}{2}}$，也就是$e^{-\frac{\pi}{2}}$，然而它是个实数，约等于$0.207879576350762$。</p><p>类似这样，可以得出$i^x=e^{\frac{i\pi x}{2}}$，再进行变换得出以$i$为底的对数函数$\log_i x=\frac{2\ln x}{i\pi}$</p><h2 id="2-cos-i"><a href="#2-cos-i" class="headerlink" title="$2.\cos i$"></a>$2.\cos i$</h2><p>就拿这两个泰勒公式来讲吧。</p><script type="math/tex; mode=display">e^x=\frac{x^0}{0!}+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}\dots</script><script type="math/tex; mode=display">\cos x=\frac{x^0}{0!}-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^8}{8!}\dots</script><p>第二条式子代入$x=i$，得出：</p><script type="math/tex; mode=display">\cos i=\frac{i^0}{0!}-\frac{i^2}{2!}+\frac{i^4}{4!}-\frac{i^6}{6!}+\frac{i^8}{8!}\dots</script><p>这说明了$\cos i$一定是实数，为什么呢？</p><p>因为式子中$i$的幂都是偶数，而开头有写$i^{4n}=1$，$i^{4n+2}=-1$，而偶数不是$4n$就是$4n+2$了，而这样的幂都是实数，由于实数的封闭性，所以$\cos i$一定是实数。</p><p>让我们继续，化简一下：</p><script type="math/tex; mode=display">\cos i=\frac{1}{0!}+\frac{1}{2!}+\frac{1}{4!}+\frac{1}{6!}+\frac{1}{8!}\dots</script><p>这有一点像$e$的泰勒公式啊，我们列一下$e$的泰勒展开：</p><script type="math/tex; mode=display">\cos i=\frac{1}{0!}+\frac{1}{2!}+\frac{1}{4!}+\frac{1}{6!}+\frac{1}{8!}\dots</script><script type="math/tex; mode=display">e=\frac{1}{0!}+\frac{1}{1!}+\frac{1}{2!}+\frac{1}{3!}+\frac{1}{4!}\dots</script><p>这时我们想到应该把$\frac{1}{1!}$、$\frac{1}{3!}$这一类的东西去掉，再看一眼$e^x$的泰勒公式，就会恍然大悟：</p><script type="math/tex; mode=display">e^x=\frac{x^0}{0!}+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}\dots</script><p>只需要代入$x=-1$，两条式子相加再除以二就可以了！</p><script type="math/tex; mode=display">e^{-1}=\frac{1}{0!}-\frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+\frac{1}{4!}\dots</script><p>相加得</p><script type="math/tex; mode=display">e+e^{-1}=(\frac{1}{0!}+\frac{1}{2!}+\frac{1}{4!}\dots)+(\frac{1}{0!}+\frac{1}{2!}+\frac{1}{4!}\dots)</script><p>再除以二得到</p><script type="math/tex; mode=display">\frac{e+e^{-1}}{2}=\frac{1}{0!}+\frac{1}{2!}+\frac{1}{4!}\dots</script><p>也就是$\cos i$的值了。这十分惊讶，$\cos i$居然是$e$和其倒数的平均值！大约等于$1.543080634815244$。</p><h1 id="4-什么数的相反数与倒数相等？"><a href="#4-什么数的相反数与倒数相等？" class="headerlink" title="$4.$什么数的相反数与倒数相等？"></a>$4.$什么数的相反数与倒数相等？</h1><p>一天看奥数书，有一个问题：</p><blockquote><p>你能找到两个<strong>有理数</strong>，他们互为相反数，又互为倒数吗？</p></blockquote><p>当然这种题是很简单的，因为这两个数互为相反数，所以可以设为$x$和$-x$，又要满足互为倒数，那么这两个数的乘积应等于$1$，所以得出方程$x\times(-x)=1$，显然满足这个方程的有理数解是不存在的。</p><p>那么什么数的相反数与倒数相等呢？</p><p>根据本文的知识很容易就能得出$x=\sqrt{-1}$，也就是$i$。</p><p>当然也有另一种方法：</p><script type="math/tex; mode=display">1=1</script><script type="math/tex; mode=display">-i^2=1</script><script type="math/tex; mode=display">-i=\frac{1}{i}</script><h1 id="5-i-的幂"><a href="#5-i-的幂" class="headerlink" title="$5.i$的幂"></a>$5.i$的幂</h1><p>前面说过了，$i^{4n}=1$，$i^{4n+1}=i$，$i^{4n+2}=-1$，$i^{4n+3}=-i(n\in\mathbb{N})$，但是我们不能把思想禁锢在自然数中，我们得扩展直到复数。</p><h2 id="1-负整数"><a href="#1-负整数" class="headerlink" title="$1.$负整数"></a>$1.$负整数</h2><p>我们来试几个数：$i^{-1}=\frac{1}{i}$，刚刚证明了$i$的倒数和相反数相等，那么$i^{-1}=-i$。</p><p>$i^{-2}=\frac{1}{i^2}=\frac{1}{-1}=-1$</p><p>$i^{-3}=\frac{1}{i^3}=\frac{1}{-i}=-(-i)=i$</p><p>$i^{-4}=\frac{1}{i^4}=\frac{1}{1}=1$</p><p>$i^{-5}=\frac{1}{i^5}=\frac{1}{i}=-i$</p><p>在这里又出现了周期，也是$-i,-1,i,1$的循环，而且你会发现他们也符合$i^{4n}=1$，$i^{4n+1}=i$，$i^{4n+2}=-1$，$i^{4n+3}=-i$的规则！（只是这里$n$是负数而已）。</p><p>现在我们已经把整数搞定了，下一站，分数。</p><h2 id="2-分数"><a href="#2-分数" class="headerlink" title="$2.$分数"></a>$2.$分数</h2><p>这里的分数</p><h3 id="1-分子为-1-的分数"><a href="#1-分子为-1-的分数" class="headerlink" title="$1.$分子为$1$的分数"></a>$1.$分子为$1$的分数</h3><p>我们知道$i^{\frac{1}{x}}=\sqrt[x]{i}$</p><p>那么怎么求出$\sqrt[1]{i}$、$\sqrt[2]{i}$、$\sqrt[3]{i}$、$\sqrt[4]{i}$$呢？</p><p>为什么只用求到$4$次方？</p><p>可以分类讨论，$p$次方根的$p$必定可以表示成$4n$、$4n+1$、$4n+2$、$4n+3$其中的一种。</p><ul><li>$p=4n+1$，那么$i^1=i^p=i^{4n+1}$，两边同时开$4n+1$次方，那么$\sqrt[4n+1]{i}=\sqrt[1]{i}$。</li><li>$p=4n+2$，那么$i^2=i^p=i^{4n+2}$，两边同时开$(4n+2)2$次方，那么$\sqrt[4n+2]{i}=\sqrt[2]{i}$。</li><li>$p=4n+3$，那么$i^3=i^p=i^{4n+3}$，两边同时开$(4n+3)3$次方，那么$\sqrt[4n+3]{i}=\sqrt[3]{i}$。</li><li>$p=4n$，那么$i^0=i^p=i^{4n}$，两边同时开$4n$次方，那么$\sqrt[4n]{i}=\sqrt[1]{i}$。</li></ul><p>证明完了，我们要开始求值了。</p><p>很容易得出$\sqrt[1]{i}$等于$i$。</p><p>接下来介绍一种方法：</p><ol><li>因为$\sqrt[2]{i}$一定可以表述成$a+bi$的形式，那么假设$\sqrt[2]{i}=a+bi$</li><li>两边同时平方，得出$i=(a+bi)^2=a^2+2abi-b^2$.</li><li>左边与右边的实数虚数部分一一对应：$0+1i=(a^2-b^2)+2abi$，那么$a^2-b^2=0$，$2ab=1$。</li><li>解出这个方程组，得出$a=b=\sqrt{\frac{1}{2}}$或$-\sqrt{\frac{1}{2}}$，那么，$\sqrt[2]{i}=\pm\frac{1+i}{\sqrt{2}}$</li></ol><p>类似这样，我们可以求出$\sqrt[3]{i}$和$\sqrt[4]{i}$的值了！</p><p>这里给出$\sqrt[3]{i}$的解：$\sqrt[3]{i}=-i=\frac{i\pm\sqrt{3}}{2}$</p><h3 id="2-分子不为-1-的分数"><a href="#2-分子不为-1-的分数" class="headerlink" title="$2.$分子不为$1$的分数"></a>$2.$分子不为$1$的分数</h3><p>其实这很简单，因为$i^{\frac{a}{b}}={(i^{\frac{1}{b}})}^a$，而且我们知道$i^{\frac{1}{b}}$的值，那么代入再$a$次方即可。</p><p>至此，我们将有理数完成了。</p><h2 id="3-无理数"><a href="#3-无理数" class="headerlink" title="$3.$无理数"></a>$3.$无理数</h2><p>目前我还没有想到这一类的解决方法，如果你们可以，请在下方评论区告诉我，谢谢。</p><h2 id="4-复数"><a href="#4-复数" class="headerlink" title="$4.$复数"></a>$4.$复数</h2><p>假使我们将实数搞定了（也就是无理数可以解决了），那么就到了虚数，但是虚数已经知道了$i^i=e^{-\frac{\pi}{2}}$。</p><p>那么，我们将开始最后一站——复数。</p><p>复数是类似于$a+bi$的数，之前有提及过。</p><p>那么$i^{a+bi}=i^a\times i^{bi}$，左边的$i^a$我们已经可以求了，右边我们可以再变换：$i^{bi}={(i^i)}^b=(e^{-\frac{\pi}{2}})^b$。</p><p>综合起来，$i^{a+bi}=i^a\times e^{-\frac{\pi b}{2}}$</p><p>现在，我们就可以求出$i$的任何次幂了。</p><h2 id="5-i-x-1-？？？"><a href="#5-i-x-1-？？？" class="headerlink" title="$5.i^{x}=1$？？？"></a>$5.i^{x}=1$？？？</h2><p>我发现一个结论，就是$i$的任何次方都是$1$。</p><p>这个结论也许是错的，我不能推翻它。</p><p>从下面的式子可以看出：</p><script type="math/tex; mode=display">i^x=i^{4\times\frac{x}{4}}={(i^4)}^{\frac{x}{4}}=1^{\frac{x}{4}}=1</script><p>如果你们能推翻它，请在下方评论区告诉我，谢谢。</p><h1 id="6-Bug"><a href="#6-Bug" class="headerlink" title="$6.Bug$"></a>$6.Bug$</h1><p>作为文章的最后，给大家再看一个悖论：</p><script type="math/tex; mode=display">\frac{-1}{1}=\frac{1}{-1}</script><script type="math/tex; mode=display">\sqrt{\frac{-1}{1}}=\sqrt{\frac{1}{-1}}</script><script type="math/tex; mode=display">\frac{\sqrt{-1}}{\sqrt{1}}=\frac{\sqrt{1}}{\sqrt{-1}}</script><script type="math/tex; mode=display">\frac{i}{1}=\frac{1}{i}</script><script type="math/tex; mode=display">1=i^2</script><script type="math/tex; mode=display">1=-1</script><p>当然这肯定是有很大的$bug$的，这就让你们自己去探索吧。</p><hr><script type="math/tex; mode=display">\Huge The\ End.</script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么B站用户看抖音用户不顺眼</title>
      <link href="/2019/%E4%B8%BA%E4%BB%80%E4%B9%88B%E7%AB%99%E7%94%A8%E6%88%B7%E7%9C%8B%E6%8A%96%E9%9F%B3%E7%94%A8%E6%88%B7%E4%B8%8D%E9%A1%BA%E7%9C%BC/"/>
      <url>/2019/%E4%B8%BA%E4%BB%80%E4%B9%88B%E7%AB%99%E7%94%A8%E6%88%B7%E7%9C%8B%E6%8A%96%E9%9F%B3%E7%94%A8%E6%88%B7%E4%B8%8D%E9%A1%BA%E7%9C%BC/</url>
      
        <content type="html"><![CDATA[<p>$By\ RioBlu$</p><p>新兴的短视频软件迭出不穷，但大多$B$站用户却一直对这类软件持否定的态度</p><p>这是为什么呢？</p><a id="more"></a><h2 id="首先先介绍一下Bilibili"><a href="#首先先介绍一下Bilibili" class="headerlink" title="首先先介绍一下Bilibili"></a>首先先介绍一下Bilibili</h2><p>哔哩哔哩$(bilibili)$现为国内领先的年轻人文化社区，是一个知名的视频弹幕网站，它的特色不用说，就是弹幕（让我想起了之前某视频卡死电脑的经历）</p><p>人称B站，与A站$(AcFun)$，N站$(NicoNico)$在二次元视频弹幕网站可谓是三霸</p><h3 id="B站的优势在哪呢？"><a href="#B站的优势在哪呢？" class="headerlink" title="B站的优势在哪呢？"></a>B站的优势在哪呢？</h3><ul><li><p>有很多不同视频分区的大佬（放假君、中国$boy$、山下智博、$papi$酱、敖厂长、欣小萌、$ilem$，李永乐等大佬）</p></li><li><p>底蕴足，相比$C$站$O$站$D$站这种网站可谓是早了数年（$2009$年建立）</p></li><li><p>有很多播放上千万的番剧/国创，镇站之宝(比如 我的烤面筋融化你的心，我单集循环了$10$次)</p></li><li><p>舞蹈区的大佬，女装，二次元化，$cosplay$，番剧。自然会吸引很多宅男宅女和很多年轻人</p></li></ul><hr><h2 id="后面我们来介绍短视频软件中比较火的抖音"><a href="#后面我们来介绍短视频软件中比较火的抖音" class="headerlink" title="后面我们来介绍短视频软件中比较火的抖音"></a>后面我们来介绍短视频软件中比较火的抖音</h2><p>抖音，是一个拍短视频的音乐创意视频社交软件，而且是一个专注年轻人音乐短视频社区平台，在我天天听我妹看抖音的熏陶下，在我的心目中，抖音的特色是：音乐，搞笑，吃鸡的一些对话（或许搞笑，或许感动，或许有关小哥哥救小姐姐）</p><p>与其类似的还有快手，微视，火山小视频（人称：南抖音，北快手，智障界两泰斗）</p><h3 id="抖音的优势在哪呢？"><a href="#抖音的优势在哪呢？" class="headerlink" title="抖音的优势在哪呢？"></a>抖音的优势在哪呢？</h3><ul><li><p>大规模宣传，在许许多多的综艺视频中宣传，甚至在2019年春晚都有它的身影</p></li><li><p>内容搞笑，内容丰富多样</p></li><li><p>音乐，大多数很火的音乐都从这儿开始火</p></li><li><p>方便，随时都可以刷</p></li></ul><hr><h2 id="那B站的用户为什么看抖音不顺眼"><a href="#那B站的用户为什么看抖音不顺眼" class="headerlink" title="那B站的用户为什么看抖音不顺眼"></a>那B站的用户为什么看抖音不顺眼</h2><p>我是一个$B$站人士，所以为什么$B$站的人对抖音不顺眼是深有感触的</p><ul><li><p>刻板印象，对于那些在裤裆里放鞭炮早有耳闻，同时在$2019$年$4$月，$B$站后台泄露，部分账号可以在快视频登录这些都影响了B站用户对短视频软件的看法</p></li><li><p>内容表现方式不同，抖音是短视频平台，而B站是长视频平台，短视频没有像B站有鬼畜区，游戏区，科普区。相对来说可以在$B$站学到的知识比较系统化，有真正的老师来直播授课。</p></li><li><p>认为那些东西低俗，营销，对于那些小孩子不大好（印尼已经禁止了抖音在海外版的$Hik Tok$）</p></li><li><p>抖音用户可以在几十分钟内很方便的造好一个视频，而$B$站$up$主需要几天甚至几月才能做完一个视频</p></li><li><p>出现负面事件，比如：（邱少云，被$**$ 这种侮辱烈士的内容）</p></li><li><p>一些抖音搬运视频，百万播放量并不少见，可B站的原创$up$主可只有几万的播放量时，很难对抖音产生认同</p></li><li><p>版权问题比较严重，盗用一些作者明确有声明的视频音频</p></li></ul><p>在这里举几个例子：</p><ul><li><p>莉哥被封杀：她篡改了国歌歌词，并且还在直播时演唱了改编版本。莉哥后来因公然侮辱国歌被行政拘留，再后来她也就被封杀了。</p></li><li><p>网上有一个比较火的模仿叫“我们一起学猫叫”，很多人都在模仿拍摄，给网友们带来了新鲜和搞笑。但是其中却有一个小姑娘就拍自己模仿视频的时候不小心拍下了不雅事件并传播了出去。视频里面记录了小姑娘巧合之下拍到的妈妈洗澡的视频，就是这么巧，那个时候浴室的门没有关闭严实。就是这段视频，小姑娘上传到网络，抖音居然上“推荐”是什么意思？这不仅仅是暴露了小姑娘的家庭隐私，引起矛盾纠纷，而且充满了巨大的负能量和消极的不良影响。</p></li></ul><hr><h2 id="作为一个B站用户对抖音的建议"><a href="#作为一个B站用户对抖音的建议" class="headerlink" title="作为一个B站用户对抖音的建议"></a>作为一个B站用户对抖音的建议</h2><ul><li><p>审核水平有待提高，降低不良事故的发生可能性，这样可以提高抖音在$B$站用户在心中的地位</p></li><li><p>提高用户道德修养，现在抖音也有一些公益广告加入了，亦更新了与时俱进的健康系统</p></li><li><p>注重版权问题，拒绝盗版，尊重原作者的劳动成果</p></li><li><p>提高视频质量，加强直播监控</p></li></ul><hr><p>说了这么多，也希望抖音可以改进到一个良好状态，现在也有不少$B$站$up$主去抖音改善环境，其中我认识的以籽岷较为有名，他也鼓励一些朋友一起去改善那里</p><p>最后衷心的祝愿抖音和$B$站发展的越来越好，$Bye$</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bilibili </tag>
            
            <tag> 抖音 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,World!</title>
      <link href="/2019/Hello-World/"/>
      <url>/2019/Hello-World/</url>
      
        <content type="html"><![CDATA[<p><img src="\images\avatar.jpg" alt></p><script type="math/tex; mode=display">\Huge2019.7.11</script><a id="more"></a><hr><h1 id="1-关于我们"><a href="#1-关于我们" class="headerlink" title="$1.$关于我们"></a>$1.$关于我们</h1><h2 id="1-博客概况"><a href="#1-博客概况" class="headerlink" title="$1.$博客概况"></a>$1.$博客概况</h2><p>这个博客由两人共同创建，主要涉及数学、计算机科学、学习笔记等方面。</p><p>一个是我$King$，还有是$RioBlu$，这也是名称$R\&amp;K$的由来。</p><ul><li>共同爱好：扫雷 $2048$ $bilibili$ 电音</li><li>出产地：中国广东</li></ul><p>如果不出意外，博客每周会更$2$篇。即使会少也会赶回来。</p><h2 id="2-2005czq-是什么？为什么是-2019-7-11-？"><a href="#2-2005czq-是什么？为什么是-2019-7-11-？" class="headerlink" title="$2.2005czq$是什么？为什么是$2019.7.11$？"></a>$2.2005czq$是什么？为什么是$2019.7.11$？</h2><p>$2005$是我们的生产日期，而$czq$是$King$的名字。</p><p>而在$2019$，我们$14$岁上初一，也就是$7$年级，而且正好$7.11$是刚考完试的第一天。</p><h2 id="3-如何联系我们"><a href="#3-如何联系我们" class="headerlink" title="$3.$如何联系我们"></a>$3.$如何联系我们</h2><p>可以通过$QQ$联系，</p><p>$RioBlu$的$QQ:$<a href="https://wpa.qq.com/msgrd?v=3&amp;uin=1270585465" target="_blank" rel="noopener">1270585465</a></p><p>$King$的$QQ:$<a href="https://wpa.qq.com/msgrd?v=3&amp;uin=3376299315" target="_blank" rel="noopener">3376299315</a></p><p>可以<a href="https://github.com/2005czq" target="_blank" rel="noopener">$Github$</a>联系，但是不常上$Github$。</p><h1 id="2-投喂"><a href="#2-投喂" class="headerlink" title="$2.$投喂"></a>$2.$投喂</h1><p>如果您觉得小站对您有帮助，可以通过投喂来支持我们，您的支持将鼓励我们继续创作！</p><p>当然，如果您感谢我们但不能投喂，也可以向他人宣传我们的博客。十分感谢。</p><p>对于一次投喂$\ge5$软妹币的，会进入到致谢名单，我们对您以诚挚的感谢。</p><p>我们将使用这些资金购买和续费域名。</p><h1 id="3-友链"><a href="#3-友链" class="headerlink" title="$3.$友链"></a>$3.$友链</h1><p>如果您的博客更好，我们可以互加友链，可以通过上面的方式联系我，也可以在下方评论我。（暂不支持头像）</p><p>博客要求：</p><ol><li>没有广告推广</li><li>会持续更新，不会咕很久</li><li>可以稳定访问</li></ol><p>我的友链：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名称：R&amp;K</span><br><span class="line">头像：https://i.loli.net/2019/07/14/5d2a0de3d8f9725674.jpg</span><br><span class="line">网站：2005czq.github.io</span><br><span class="line">说明：Doing is better than Saying.</span><br></pre></td></tr></table></figure></p><hr><p>友链：</p><ol><li><a href="https://2005czq.github.io">R&amp;K</a>的博客</li></ol><hr><p>温馨提示：</p><ol><li>在浏览本站时，因评论系统不支持$Markdown$和$\LaTeX$，所以可以将$Markdown$代码发送，若代码过长，可使用<a href="https://paste.ubuntu.com/" target="_blank" rel="noopener">这个网站</a>将代码存入，再发送网址。</li><li>如果您发现我们的文章有误，可以联系我们，也可以在下面的评论区指正，感谢！</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
